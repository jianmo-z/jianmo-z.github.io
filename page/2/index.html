<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-Socket/day08" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/01/19/Socket/day08/" class="article-date">
  <time class="dt-published" datetime="2022-01-18T16:00:00.000Z" itemprop="datePublished">2022-01-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Socket/">Socket</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/01/19/Socket/day08/">08 五种I/O模型&amp;select模型</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="day08"><a href="#day08" class="headerlink" title="day08"></a>day08</h1><h2 id="本章目标"><a href="#本章目标" class="headerlink" title="本章目标"></a>本章目标</h2><ul>
<li>五种<code>I/O</code>模型</li>
<li><code>select</code></li>
<li>用<code>select</code>改进回射客户端程序</li>
</ul>
<h2 id="五种I-O模型"><a href="#五种I-O模型" class="headerlink" title="五种I&#x2F;O模型"></a>五种I&#x2F;O模型</h2><ul>
<li>阻塞<code>I/O</code></li>
<li>非阻塞<code>I/O</code></li>
<li><code>I/O</code>复用(<code>select</code>和<code>poll</code>)</li>
<li>信号驱动<code>I/O</code></li>
<li>异步<code>I/O</code></li>
</ul>
<h2 id="1、阻塞I-O模型"><a href="#1、阻塞I-O模型" class="headerlink" title="1、阻塞I&#x2F;O模型"></a>1、阻塞I&#x2F;O模型</h2><blockquote>
<p>阻塞等待数据到来。</p>
</blockquote>
<p><img src="/./Picture/%E9%98%BB%E5%A1%9EIO%E6%A8%A1%E5%9E%8B.png" alt="阻塞IO模型"></p>
<h2 id="2、非阻塞I-O模型"><a href="#2、非阻塞I-O模型" class="headerlink" title="2、非阻塞I&#x2F;O模型"></a>2、非阻塞I&#x2F;O模型</h2><blockquote>
<p>**<code>忙等待</code>**，用的很少，程序一直在等待数据，没有数据相当于死循环，占用CPU资源。</p>
</blockquote>
<p><img src="/./Picture/%E9%9D%9E%E9%98%BB%E5%A1%9EIO%E6%A8%A1%E5%9E%8B.png" alt="非阻塞IO模型"></p>
<blockquote>
<p><code>fcntl(fd, F_SETFL, flag|O_NONBLOCK);</code></p>
<p>详情查看本博客C语言部分：<a target="_blank" rel="noopener" href="http://39.106.165.33/#!./blog/C/4.C%E8%AF%AD%E8%A8%80%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1.md">跳转连接</a></p>
<p>PS：<code>EMOULDBLOCK</code>错误应当改为<code>EWOULDBLOCK</code></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">NAME</span><br><span class="line">       fcntl - manipulate file descriptor</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       #include &lt;unistd.h&gt;</span><br><span class="line">       #include &lt;fcntl.h&gt;</span><br><span class="line"></span><br><span class="line">       int fcntl(int fd, int cmd, ... /* arg */ );</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">       fcntl() performs one of the operations described below on the open file</span><br><span class="line">       descriptor fd.  The operation is determined by cmd.</span><br><span class="line">       fcntl() can take an optional third argument.  Whether or not this argu‐</span><br><span class="line">       ment  is  required is determined by cmd.  The required argument type is</span><br><span class="line">       indicated in parentheses after  each  cmd  name  (in  most  cases,  the</span><br><span class="line">       required type is int, and we identify the argument using the name arg),</span><br><span class="line">       or void is specified if the argument is not required.</span><br><span class="line">       </span><br><span class="line">RETURN VALUE</span><br><span class="line">       For a successful call, the return value depends on the operation:</span><br><span class="line">       F_DUPFD  The new descriptor.</span><br><span class="line">       F_GETFD  Value of file descriptor flags.</span><br><span class="line">       F_GETFL  Value of file status flags.</span><br><span class="line">       F_GETLEASE</span><br><span class="line">                Type of lease held on file descriptor.</span><br><span class="line">       F_GETOWN Value of descriptor owner.</span><br><span class="line">       F_GETSIG Value of signal sent when read or write becomes  possible,  or</span><br><span class="line">                zero for traditional SIGIO behavior.</span><br><span class="line">       F_GETPIPE_SZ</span><br><span class="line">                The pipe capacity.</span><br><span class="line">       All other commands</span><br><span class="line">                Zero.</span><br><span class="line">On error, -1 is returned, and errno is set appropriately.</span><br></pre></td></tr></table></figure>

<h2 id="3、I-O复用"><a href="#3、I-O复用" class="headerlink" title="3、I&#x2F;O复用"></a>3、I&#x2F;O复用</h2><p><img src="/./Picture/IO%E5%A4%8D%E7%94%A8%E6%A8%A1%E5%9E%8B.png" alt="IO复用模型"></p>
<blockquote>
<p>通过<code>select</code>来实现，通过<code>select</code>管理多个文件描述符。一旦由文件描述符监测到数据到来<code>select</code>就返回，然后调用<code>recv</code>函数对数据处理，</p>
</blockquote>
<h2 id="4、信号驱动I-O"><a href="#4、信号驱动I-O" class="headerlink" title="4、信号驱动I&#x2F;O"></a>4、信号驱动I&#x2F;O</h2><blockquote>
<p>不常用，非阻塞模式，有消息到来通过信号跳到消息处理函数，没有消息，处理其他事情。</p>
</blockquote>
<p><img src="/./Picture/%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8IO.png" alt="信号驱动IO"></p>
<h2 id="5、异步I-O"><a href="#5、异步I-O" class="headerlink" title="5、异步I&#x2F;O"></a>5、异步I&#x2F;O</h2><blockquote>
<p><code>效率最高的处理方式</code>。<code>aio_read</code>函数，有一个缓冲区，如果没有数据立即返回，有数据的话，把数据拷贝到应用层的缓冲区。复制完成后，通过信号通知应用层的数据。与第四种模型相似，但是又有很大区别。</p>
</blockquote>
<p><img src="/./Picture/%E5%BC%82%E6%AD%A5IO.png" alt="异步IO"></p>
<h2 id="select模型-—-重点"><a href="#select模型-—-重点" class="headerlink" title="select模型 —&gt;重点"></a>select模型 —&gt;重点</h2><blockquote>
<p><code>man 2 select</code>，学会使用帮助手册。</p>
<p><code>select</code>：用来管理<code>fd</code>，地位：管理者，管理多个<code>I/O</code>，一旦其中的一个<code>I/O</code>监测到所感兴趣的事件，那么<code>select</code>函数返回，返回值为监测到事件的个数。并且返回那些<code>I/O</code>发生了那些事件。遍历事件然后进行处理，单进程处理比较好。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/select.h&gt;</span><br><span class="line"></span><br><span class="line">/* According to earlier standards */</span><br><span class="line">#include &lt;sys/time.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);</span><br><span class="line"></span><br><span class="line">void FD_CLR(int fd, fd_set *set);</span><br><span class="line">int  FD_ISSET(int fd, fd_set *set);</span><br><span class="line">void FD_SET(int fd, fd_set *set);</span><br><span class="line">void FD_ZERO(fd_set *set);</span><br><span class="line"></span><br><span class="line">#include &lt;sys/select.h&gt;</span><br><span class="line"></span><br><span class="line">int pselect(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, const struct timespec *timeout, const sigset_t *sigmask);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>select</code>的参数说明：<ul>
<li><p><code>int nfds</code>：存放到读、写、异常的集合文件描述符的<code>最大值+1</code>。就是改参数的值。</p>
</li>
<li><p><code>fd_set *readfds</code>：读的集合，如果有数据可读的套接口放在此集合，放的为文件描述符。<strong>输入输出型参数。</strong></p>
</li>
<li><p><code>fd_set *writefds</code>：写的集合，如果有数据可写的套接口放在此集合，放的为文件描述符。<strong>输入输出型参数。</strong></p>
</li>
<li><p><code>fd_set *exceptfds</code>：异常的集合<strong>输入输出型参数。</strong></p>
</li>
<li><p><code>struct timeval *timeout</code>：指定超时时间，<code>NULL</code>不设置超时时间。设置时间后如果没有监测到时间，也会返回返回值为<code>0</code>。<strong>输入输出型参数。</strong></p>
<blockquote>
<p><font color=red size=5><code>select</code>函数每次返回一次，都需要调用<code>FD_ZERO</code>和<code>FD_SET</code>，因为第二、三、四个参数都是输入输出型参数，返回后其值会发生变化，需要重新设置内容。</font></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">fd_set rset;</span><br><span class="line">FD_ZERO(&amp;rset);</span><br><span class="line">int maxfd;</span><br><span class="line">int nready;</span><br><span class="line">char sendbuf[1024] = &#123;0&#125;;</span><br><span class="line">char recvbuf[1024] = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">int fd_stdin = fileno(stdin);//为了防止标准输入和输出被重定向所以用fileno转换stdin/stdout为fd</span><br><span class="line">if(fd_stdin &gt; sock)//设置最大fd</span><br><span class="line">	maxfd = fd_stdin;</span><br><span class="line">else</span><br><span class="line">	maxfd = sock;</span><br><span class="line">while(1)</span><br><span class="line">&#123;</span><br><span class="line">    FD_SET(fd_stdin, &amp;rset);//每次都需要添加在while循环,详情查看博客原因</span><br><span class="line">    FD_SET(sock, &amp;rset);</span><br><span class="line">    nready = select(maxfd + 1, &amp;rset, NULL, NULL, NULL);</span><br><span class="line">    if(nready == -1)</span><br><span class="line">    &#123;</span><br><span class="line">    	ERR_EXIT(&quot;select&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else if(nready == 0)</span><br><span class="line">    	continue;</span><br><span class="line">    if(FD_ISSET(sock, &amp;rset))//判断是那个信号的，调其处理的函数</span><br><span class="line">    &#123;</span><br><span class="line">    	int ret = readline(sock, recvbuf, sizeof(recvbuf));</span><br><span class="line">    	if(ret == -1)</span><br><span class="line">        &#123;</span><br><span class="line">        ERR_EXIT(&quot;readline&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        else if(ret == 0)</span><br><span class="line">        &#123;</span><br><span class="line">        printf(&quot;server close\n&quot;);</span><br><span class="line">        break;</span><br><span class="line">        &#125;</span><br><span class="line">    	fputs(recvbuf, stdout);</span><br><span class="line">   		memset(recvbuf, 0, sizeof(recvbuf));</span><br><span class="line">    &#125;</span><br><span class="line">    else if(FD_ISSET(fd_stdin, &amp;rset))</span><br><span class="line">    &#123;</span><br><span class="line">        if(fgets(sendbuf, sizeof(sendbuf), stdin) == NULL)</span><br><span class="line">        break;</span><br><span class="line">        writen(sock, sendbuf, strlen(sendbuf));</span><br><span class="line">        memset(sendbuf, 0, sizeof(sendbuf));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">close(sock);</span><br><span class="line">return 0;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><code>timeout</code>的结构体：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">The timeout</span><br><span class="line">The time structures involved are defined in &lt;sys/time.h&gt; and look like</span><br><span class="line">struct timeval &#123;</span><br><span class="line">    long    tv_sec;         /* seconds */</span><br><span class="line">    long    tv_usec;        /* microseconds */</span><br><span class="line">&#125;;</span><br><span class="line">and</span><br><span class="line">struct timespec &#123;</span><br><span class="line">    long    tv_sec;         /* seconds */</span><br><span class="line">   long    tv_nsec;        /* nanoseconds */</span><br><span class="line">&#125;;</span><br><span class="line">&gt; (However, see below on the POSIX.1-2001 versions.)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>select</code>的返回值：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RETURN VALUE</span><br><span class="line">On success, select() and pselect() return the  number  of  file  descriptors  contained  in  the  three returned  descriptor  sets  (that  is,  the  total  number  of  bits that are set in readfds, writefds, exceptfds) which may be zero if the timeout expires before anything interesting happens.  On error,  -1 is  returned,  and errno is set appropriately; the sets and timeout become undefined, so do not rely on their contents after an error.</span><br></pre></td></tr></table></figure>

<ul>
<li><p>四个宏</p>
<ul>
<li><p><code>void FD_CLR(int fd, fd_set *set);</code></p>
<blockquote>
<p>如果<code>fd</code>存在于集合中，将<code>fd</code>从集合中移除。</p>
</blockquote>
</li>
<li><p><code>int  FD_ISSET(int fd, fd_set *set);</code></p>
<blockquote>
<p>判定<code>fd</code>是否再集合中，不会改变集合的内容。</p>
</blockquote>
</li>
<li><p><code>void FD_SET(int fd, fd_set *set);</code></p>
<blockquote>
<p>将<code>fd</code>添加到集合当中</p>
</blockquote>
</li>
<li><p><code>void FD_ZERO(fd_set *set);</code></p>
<blockquote>
<p>将集合清空，即删除集合内所有的<code>fd</code></p>
</blockquote>
</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/01/19/Socket/day08/" data-id="cm3mpi62b002tl0ya92yj602n" data-title="08 五种I/O模型&amp;select模型" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Socket-I-O%E6%A8%A1%E5%9E%8B/" rel="tag">Socket I&#x2F;O模型</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/select%E6%A8%A1%E5%9E%8B/" rel="tag">select模型</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Socket/day10" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/01/19/Socket/day10/" class="article-date">
  <time class="dt-published" datetime="2022-01-18T16:00:00.000Z" itemprop="datePublished">2022-01-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Socket/">Socket</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/01/19/Socket/day10/">10 close和shutdown函数</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="day10"><a href="#day10" class="headerlink" title="day10"></a>day10</h1><h2 id="本章目标"><a href="#本章目标" class="headerlink" title="本章目标"></a>本章目标</h2><ul>
<li><code>close</code>和<code>shutdown</code>的区别</li>
<li>进一步改进回射客户端程序</li>
</ul>
<h2 id="close和shutdown"><a href="#close和shutdown" class="headerlink" title="close和shutdown"></a>close和shutdown</h2><ul>
<li><p><code>close</code>终止了数据传送的两个方向</p>
</li>
<li><p><code>shutdown</code>可以有选择的终止某个方向的数据传送或者终止数据传送的两个方向</p>
</li>
<li><p><code>shutdown how=1</code>就可以保证对等方接收到一个<code>EOF</code>字符，而不管其他进程是否已经打开了套接字，即不关心引用计数。而<code>close</code>不能保证一定给对等方发送<code>EOF</code>，而是直到套接字引用计数减为<code>0</code>时才发送，也就是说直到所有的进程都关闭了套接字。才是真的关闭了套接字。</p>
<blockquote>
<p><code>FIN</code>：是用来扫描保留的端口，发送一个FIN包（或者是任何没有<code>ACK</code>或<code>SYN</code>标记的包）到目标的一个开放的端口，然后等待回应。许多系统会返回一个复位标记。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>当客户端(或者服务器)发送消息后，另一端没有读取消息，消息还在管道中，但是客户端(或者服务器)使用<code>close</code>关闭了套接字，那么另一端就不能把未读取的数据读取出来。所以需要<code>shutdown</code>，终止某个方向的数据传送。</p>
</blockquote>
<p>关于<code>shutdown</code>和<code>close</code>参考文档：<a target="_blank" rel="noopener" href="https://blog.csdn.net/lgp88/article/details/7176509">https://blog.csdn.net/lgp88/article/details/7176509</a></p>
<h2 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h2><blockquote>
<p><code>man 2 shutdown</code>查看帮助，这个是一个函数，和<code>linux</code>命令一样但是… …，这俩不一样</p>
<p><strong>假设客户端使用了<code>close(fd)</code>，那么客户端的其他进程如果也使用了这个套接字(即：引用计数 &gt; 1)，则只是引用计数减一操作，其他的进程仍然可以通过这个套接字与服务器进行通信。</strong></p>
<p><strong>假设客户端如果使用了<code>shutdown(fd, SHUT_RD)</code>，则直接关闭读端(不管引用计数为多少)，其他进程则不能通过读端再进行数据的读取了，同理可得<code>SHUT_WR</code>：关闭写端，<code>SHUT_RDWR</code>：读端和写端都关闭。</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line"></span><br><span class="line">int shutdown(int sockfd, int how);</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">	The  shutdown() call causes all or part of a full-duplex connection on the socket associated with sockfd to be shut down. If how is SHUT_RD, further receptions will be disallowed.  If how is SHUT_WR, further transmissions will  be  disallowed. If how is SHUT_RDWR, further receptions and transmissions will be disallowed.</span><br><span class="line"></span><br><span class="line">RETURN VALUE</span><br><span class="line">	On success, zero is returned.  On error, -1 is returned, and errno is set appropriately.</span><br><span class="line"></span><br><span class="line">ERRORS</span><br><span class="line">	EBADF  </span><br><span class="line">		sockfd is not a valid descriptor.</span><br><span class="line">	EINVAL </span><br><span class="line">		An invalid value was specified in how (but see BUGS).</span><br><span class="line">	ENOTCONN</span><br><span class="line">		The specified socket is not connected.</span><br><span class="line">	ENOTSOCK</span><br><span class="line">		sockfd is a file, not a socket.</span><br></pre></td></tr></table></figure>

<ul>
<li>参数一：<code>shutdown</code>的套接字描述符</li>
<li>参数二：关闭的状态：<code>TCP/IP</code>是全双工的<ul>
<li><code>SHUT_RD</code>：关闭读端，宏定义为<code>0</code></li>
<li><code>SHUT_WR</code>：关闭写端，宏定义为<code>1</code></li>
<li><code>SHUT_RDWR</code>：读端和写端都关闭，宏定义为<code>2</code></li>
</ul>
</li>
</ul>
<h2 id="注意啦"><a href="#注意啦" class="headerlink" title="注意啦"></a>注意啦</h2><blockquote>
<p>本篇博客请重点查看下代码，因为这篇博客不好整理，所以… …</p>
<p><code>echocli.c</code>的<code>185-186行</code>、<code>205行</code>、<code>215-217行</code></p>
<p><code>echosrv.c</code>的<code>279-282行</code>、<code>286行</code></p>
<p>有注释所以应该可以比较好理解</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/01/19/Socket/day10/" data-id="cm3mpi62b002wl0ya1hgyheix" data-title="10 close和shutdown函数" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/close%E5%87%BD%E6%95%B0-shutdown%E5%87%BD%E6%95%B0/" rel="tag">close函数 - shutdown函数</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Socket/day09" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/01/19/Socket/day09/" class="article-date">
  <time class="dt-published" datetime="2022-01-18T16:00:00.000Z" itemprop="datePublished">2022-01-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Socket/">Socket</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/01/19/Socket/day09/">09 select并发服务器</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="day09"><a href="#day09" class="headerlink" title="day09"></a>day09</h1><h2 id="本章目标"><a href="#本章目标" class="headerlink" title="本章目标"></a>本章目标</h2><ul>
<li><code>select</code></li>
<li>读、写、异常事件发生条件</li>
<li>用<code>select</code>改进回射服务器程序</li>
</ul>
<h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><blockquote>
<p>再复习和补充一点<code>select</code>的参数</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/select.h&gt;</span><br><span class="line"></span><br><span class="line">/* According to earlier standards */</span><br><span class="line">#include &lt;sys/time.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);</span><br><span class="line"></span><br><span class="line">void FD_CLR(int fd, fd_set *set);</span><br><span class="line">int  FD_ISSET(int fd, fd_set *set);</span><br><span class="line">void FD_SET(int fd, fd_set *set);</span><br><span class="line">void FD_ZERO(fd_set *set);</span><br><span class="line"></span><br><span class="line">#include &lt;sys/select.h&gt;</span><br><span class="line"></span><br><span class="line">int pselect(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, const struct timespec *timeout, const sigset_t *sigmask);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>参数一：<code>int nfds</code></p>
<blockquote>
<p>因为<code>select</code>的对感兴趣的<code>fd</code>取值范围为<code>[0, nfds)</code>，前闭后开区间，所以需要最大的<code>文件描述符+1</code>，才能覆盖整个感兴趣的文件描述符号的范围。</p>
</blockquote>
</li>
<li><p>参数二：<code>fd_set *readfds</code></p>
<blockquote>
<p>可读事件集合，添加感兴趣可读<code>fd</code></p>
</blockquote>
</li>
<li><p>参数三：<code>fd_set *writefds</code></p>
<blockquote>
<p>可写事件集合，添加感兴趣可写<code>fd</code></p>
</blockquote>
</li>
<li><p>参数四：<code>fd_set *exceptfds</code></p>
<blockquote>
<p>异常事件集合</p>
</blockquote>
</li>
<li><p>参数五：<code>struct timeval *timeout</code></p>
<blockquote>
<p>超时时间，在响应的超时时间内没有发生任何一个<code>I/O事件</code>(读&#x2F;写事件)，则<code>select</code>返回<code>0</code>，指示超时。出现错误<code>select</code>返回<code>-1</code>.</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>监测到多个事件，需要遍历，<code>readfds</code>、<code>writefds</code>、<code>exceptfds</code>这些集合来一一处理这些事情，<font color=read>则将<code>select</code>实现的服务器称为并发服务器</font>。因为没有能力并行处理这些<code>I/O</code>事件，只能一一遍历处理这些事件。所以称为并发服务器，而不是并行服务器。并发服务器不能长时间处理这些事件，因为长时间处理则不能去执行其他的动作。且事件间的处理间隔时间也不能太长。无法充分利用多核处理器。使用多进程<code>select</code>或者多线程处理这些事件。</p>
<p><code>select</code>可以同时检测网络<code>I/O</code>和标准<code>I/O</code>事件。那个事件产生则处理那个事件。不会因为某一个阻塞导致另一个无法处理。</p>
</blockquote>
<h2 id="读、写、异常事件发生条件"><a href="#读、写、异常事件发生条件" class="headerlink" title="读、写、异常事件发生条件"></a>读、写、异常事件发生条件</h2><ul>
<li>可读<ul>
<li>套接口缓冲区有数据可读，底层本质：如果缓冲区的数据超过一定的范围才会通知有数据可读</li>
<li>连接的读一般关闭，即接收到<code>FIN</code>段，读操作返回<code>0</code></li>
<li>如果是监听套接口，已完成连接队列不为空时。</li>
<li>套接口上发生了一个错误待处理，错误可以通过<code>getsockopt</code>指定<code>SO_ERROR</code>选项来获取</li>
</ul>
</li>
<li>可写<ul>
<li>套接口发送缓冲区有空间容纳数据</li>
<li>连接的写一半关闭，即收到<code>RST</code>段之后，再次调用<code>write</code>操作</li>
<li>套接口上发生一个错误待处理，错误可以通过<code>getsockopt</code>指定<code>SO_ERROR</code>选项来获取</li>
</ul>
</li>
<li>异常<ul>
<li>套接口存在带外数据。</li>
</ul>
</li>
</ul>
<h2 id="并发服务器"><a href="#并发服务器" class="headerlink" title="并发服务器"></a>并发服务器</h2><blockquote>
<p>对上一次的服务器端通过<code>select</code>使用一个进程实现。并发服务器的连接客户端的限制，<code>FD_SETSZIE</code>大小和一个进程当中能够打开的<code>I/O</code>的最大数目。<code>FD_SETSIZE</code>不能被更改(非要更改，需要更改内核代码，并进行重新编译)，而一个进程的可以打开的最大的<code>I/O</code>数目可以更改，通过<code>ulimit -n 1000</code>命令更改一个进程可以打开的最大<code>I/O</code>数目为<code>1000</code>。<code>FD_SETSIZE</code>默认情况下和进程能够打开的最大<code>I/O</code>数目为<code>1024</code>个。</p>
</blockquote>
<blockquote>
<p>核心代码(<strong>部分代码</strong>)</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">int i = 0;</span><br><span class="line">int num = 0;</span><br><span class="line">int maxi = 0; //最大不空闲的套接口下标</span><br><span class="line">int nready = 0;</span><br><span class="line">int maxfd = listenfd;</span><br><span class="line">int conn[FD_SETSIZE] = &#123;0&#125;;</span><br><span class="line">fd_set rset;</span><br><span class="line">fd_set allset;</span><br><span class="line">FD_ZERO(&amp;rset);</span><br><span class="line">FD_ZERO(&amp;allset);</span><br><span class="line">FD_SET(listenfd, &amp;allset);</span><br><span class="line">struct sockaddr_in sockname;</span><br><span class="line">socklen_t addrlen = sizeof(sockname);//一定要有初始值，为结构体大小，输入输出型参数。</span><br><span class="line">for(i = 0; i &lt; FD_SETSIZE; i++)//初始化conn数组</span><br><span class="line">&#123;</span><br><span class="line">        conn[i] = -1;</span><br><span class="line">&#125;</span><br><span class="line">while(1)//一个进程处理并发</span><br><span class="line">&#123;</span><br><span class="line">        rset = allset;</span><br><span class="line">        nready = select(maxfd + 1, &amp;rset, NULL, NULL, NULL);</span><br><span class="line">        if(nready == -1)</span><br><span class="line">        &#123;</span><br><span class="line">                //errno 是记录系统的最后一次错误代码。</span><br><span class="line">                //EINTR错误的产生：当阻塞于某个慢系统调用的一个进程捕获某个信号且相应信号处理函数返回时，该系统调用可能返回一个EINTR错误。</span><br><span class="line">                if(errno == EINTR)//如果被信号中断则继续</span><br><span class="line">                        continue;</span><br><span class="line">                ERR_EXIT(&quot;select&quot;);//其他错误退出</span><br><span class="line">        &#125;</span><br><span class="line">        else if(nready == 0)</span><br><span class="line">        &#123;</span><br><span class="line">                //时间超时,因为这里没有设置超时时间，理论不会出现nready == 0的情况</span><br><span class="line">                continue;</span><br><span class="line">        &#125;</span><br><span class="line">        if(FD_ISSET(listenfd, &amp;rset))//判断监听套接口是否在集合当中,处理监听套接口的数据</span><br><span class="line">        &#123;</span><br><span class="line">                int ret = -1;</span><br><span class="line">                if((ret = accept(listenfd, (struct sockaddr *)&amp;peeraddr, (socklen_t *)&amp;peerlen)) &lt; 0)</span><br><span class="line">                &#123;</span><br><span class="line">                        ERR_EXIT(&quot;accept&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                for(i = 0; i &lt; FD_SETSIZE; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                        if(conn[i] &lt; 0)</span><br><span class="line">                        &#123;</span><br><span class="line">                                conn[i] = ret;</span><br><span class="line">                                if(i &gt; maxi)</span><br><span class="line">                                        maxi = i;//最大不空闲套接口下标，优化遍历时间，提高效率</span><br><span class="line">                                break;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if(i == FD_SETSIZE)</span><br><span class="line">                &#123;</span><br><span class="line">                        //stderr标准错误</span><br><span class="line">                        fprintf(stderr, &quot;链接的客户端太多了... ...&quot;);</span><br><span class="line">                        exit(EXIT_FAILURE);</span><br><span class="line">                &#125;</span><br><span class="line">                //获取远程的地址</span><br><span class="line">                if(0 &gt; getpeername(ret , (struct sockaddr *)&amp;sockname, (socklen_t*)&amp;addrlen))</span><br><span class="line">                &#123;</span><br><span class="line">                        perror(&quot;getsockname&quot;);</span><br><span class="line">                        exit(EXIT_FAILURE);//退出程序</span><br><span class="line">                &#125;</span><br><span class="line">                printf(&quot;远程的IP: %s, Port: %d\n&quot;, inet_ntoa(sockname.sin_addr), ntohs(sockname.sin_port));</span><br><span class="line">                FD_SET(ret, &amp;allset);//添加新的套接口到allset中下一次select会检测这个套接口</span><br><span class="line">                if(maxfd &lt; ret)//需要更新最大描述符</span><br><span class="line">                        maxfd = ret;</span><br><span class="line">                if(--nready &lt;= 0)//已经处理完了监听套接口的事件，把nready减一操作，如果等于零，说明没有要处理的事件了，为了提高效率直接continue,如果不小于等于零，说明还有其他事件，即为连接客户端的事件，&gt;然后对客户端的事件进行处理，</span><br><span class="line">                        continue;</span><br><span class="line">        &#125;</span><br><span class="line">        for(i = 0; i &lt;= maxi; i++)</span><br><span class="line">        &#123;</span><br><span class="line">                if(conn[i] == -1)</span><br><span class="line">                        continue;</span><br><span class="line">                if(FD_ISSET(conn[i], &amp;rset))//判断是否在读的集合当中</span><br><span class="line">                &#123;</span><br><span class="line">                        //读取数据</span><br><span class="line">                        char recvbuf[1024] = &#123;0&#125;;</span><br><span class="line">                        int ret = readline(conn[i], recvbuf, 1024);</span><br><span class="line">                        if(ret == -1)</span><br><span class="line">                        &#123;</span><br><span class="line">                                ERR_EXIT(&quot;readline&quot;);</span><br><span class="line">                        &#125;</span><br><span class="line">                        if(0 == ret)</span><br><span class="line">                        &#123;</span><br><span class="line">                                printf(&quot;对方关闭了Socket readline\n&quot;);</span><br><span class="line">                                FD_CLR(conn[i], &amp;allset);//从allset中清除</span><br><span class="line">                                conn[i] = -1;//标志为-1</span><br><span class="line">                                continue;</span><br><span class="line">                        &#125;</span><br><span class="line">                        printf(&quot;服务器接收到的数据:&quot;);</span><br><span class="line">                        fputs(recvbuf, stdout);</span><br><span class="line">                        writen(conn[i], recvbuf, strlen(recvbuf));//数据回射回去:</span><br><span class="line">                        if(--nready &lt;= 0)</span><br><span class="line">                                break;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        FD_ZERO(&amp;rset);//清空rset</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/01/19/Socket/day09/" data-id="cm3mpi62c002zl0yae14274by" data-title="09 select并发服务器" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/select%E6%9C%8D%E5%8A%A1%E5%99%A8/" rel="tag">select服务器</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Socket/day11" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/01/19/Socket/day11/" class="article-date">
  <time class="dt-published" datetime="2022-01-18T16:00:00.000Z" itemprop="datePublished">2022-01-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Socket/">Socket</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/01/19/Socket/day11/">11 套接字IO超时设置&amp;errno&amp;fcntl&amp;getsockopt</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="day11"><a href="#day11" class="headerlink" title="day11"></a>day11</h1><h2 id="本章目标"><a href="#本章目标" class="headerlink" title="本章目标"></a>本章目标</h2><ul>
<li>套接字<code>I/O</code>超时设置方法</li>
<li>用<code>select</code>实现超时<ul>
<li><code>read_timeout</code>函数封装</li>
<li><code>write_timeout</code>函数封装</li>
<li><code>accept_timeout</code>函数封装</li>
<li><code>connect_timeout</code>函数封装</li>
</ul>
</li>
</ul>
<h2 id="套接字I-O超时设置方法"><a href="#套接字I-O超时设置方法" class="headerlink" title="套接字I&#x2F;O超时设置方法"></a>套接字I&#x2F;O超时设置方法</h2><blockquote>
<p>一共有三种方法</p>
</blockquote>
<ul>
<li><code>alarm</code>：闹钟定时</li>
<li>套接字选项：移植性比较差<ul>
<li><code>SO_SNDTIMEO</code></li>
<li><code>SO_RCVTIMEO</code></li>
</ul>
</li>
<li><code>select</code>：<strong>优</strong></li>
</ul>
<h2 id="用select实现超时"><a href="#用select实现超时" class="headerlink" title="用select实现超时"></a>用select实现超时</h2><blockquote>
<p>自定义<code>read_timeout</code>、<code>write_timeout</code>、<code>accept_timeout</code>和<code>connect_timeout</code>函数对<code>select</code>函数进行了封装，所需要参数为<code>文件描述符</code>和<code>时间长度</code></p>
</blockquote>
<blockquote>
<p>   int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);</p>
<p>   The timeout<br>       The time structures involved are defined in &lt;sys&#x2F;time.h&gt; and look like</p>
<pre><code>   struct timeval &#123;
       long    tv_sec;         /* seconds */
       long    tv_usec;        /* microseconds */
   &#125;;
</code></pre>
<p>   and</p>
<pre><code>   struct timespec &#123;
       long    tv_sec;         /* seconds */
       long    tv_nsec;        /* nanoseconds */
   &#125;;
</code></pre>
</blockquote>
<p>##errno.h头文件</p>
<blockquote>
<p>里面设置了很多的错误信息，可以通过错误信息来对函数的成功与否，以及错误原因进行详细的接收。</p>
<p>参考文档：</p>
<p>​	<a target="_blank" rel="noopener" href="http://blog.163.com/wangxun_2233/blog/static/5511009120094795756775">http://blog.163.com/wangxun_2233/blog/static/5511009120094795756775</a></p>
<p>这个博客写的很详细，不过这个没必须记，会查就行了</p>
</blockquote>
<h2 id="getsockopt函数"><a href="#getsockopt函数" class="headerlink" title="getsockopt函数"></a>getsockopt函数</h2><blockquote>
<p>参考文档：</p>
<p>​	<a target="_blank" rel="noopener" href="https://blog.csdn.net/daiyudong2020/article/details/51893399">https://blog.csdn.net/daiyudong2020/article/details/51893399</a></p>
<p><code>level</code>：设置为<code>SOL_SOCKET</code>和<code>IPPROTO_TCP</code>，详情参考上面的链接，一般设置为<code>SOL_SOCKET</code>。</p>
<p><code>optname</code>：参数<code>SO_ERROR</code>获取待处理错误并清除。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">NAME</span><br><span class="line">       getsockopt, setsockopt - get and set options on sockets</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       #include &lt;sys/types.h&gt;          /* See NOTES */</span><br><span class="line">       #include &lt;sys/socket.h&gt;</span><br><span class="line"></span><br><span class="line">       int getsockopt(int sockfd, int level, int optname,</span><br><span class="line">                      void *optval, socklen_t *optlen);</span><br><span class="line">       int setsockopt(int sockfd, int level, int optname,</span><br><span class="line">                      const void *optval, socklen_t optlen);</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">	getsockopt()  and setsockopt() manipulate options for the socket referred to by the file descriptor sockfd.  Options may exist at multiple protocol levels; they are always present at the uppermost socket level.</span><br><span class="line">	When manipulating socket options, the level at which the option resides and the name of the option  must  be  specified.   To  manipulate options at the sockets API level, level is specified as SOL_SOCKET.  To manipulate options at any other level the protocol number of the appropriate protocol controlling the option is supplied.  For example, to indicate that an option is to be interpreted by the TCP protocol, level should be set to the protocol number of TCP; see getprotoent(3).</span><br><span class="line">	The arguments optval and optlen are used to access option values for setsockopt().  For getsockopt() they identify a buffer  in  which  the  value  for the requested option(s) are to be returned.  For getsockopt(), optlen is a valueresult argument, initially containing the size of the buffer pointed to by optval, and modified on return  to  indicate the actual size of the value returned.  If no option value is to be supplied or returned, optval may be NULL.</span><br><span class="line">	Optname  and  any  specified options are passed uninterpreted to the appropriate protocol module for interpretation. The include file &lt;sys/socket.h&gt; contains definitions for socket level options, described below.   Options  at  other protocol levels vary in format and name; consult the appropriate entries in section 4 of the manual.</span><br><span class="line">	Most  socket-level  options utilize an int argument for optval.  For setsockopt(), the argument should be nonzero to enable a boolean option, or zero if the option is to be disabled.</span><br><span class="line">	For a description of the available socket options see socket(7) and the appropriate protocol man pages.</span><br><span class="line"></span><br><span class="line">RETURN VALUE</span><br><span class="line">	On success, zero is returned.  On error, -1 is returned, and errno is set appropriately.</span><br></pre></td></tr></table></figure>

<h2 id="一个函数fcntl"><a href="#一个函数fcntl" class="headerlink" title="一个函数fcntl"></a>一个函数fcntl</h2><blockquote>
<p>参考文档：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/fengxinlinux/article/details/51980837">https://blog.csdn.net/fengxinlinux/article/details/51980837</a></p>
<p><code>fcntl</code>函数，<code>man 3 fcntl</code>，<code>fcntl</code>可实现对指定文件描述符的各种操作</p>
<p>以下为该函数的<code>man手册</code>的说明，如果看不懂请到上面的连接中去学习该函数，我觉得上面的博客已经写的还不错吧，而且我的英语不太好，所以我就不卖弄自己垃圾的英语了… …。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">ROLOG</span><br><span class="line">       This  manual  page  is part of the POSIX Programmer&#x27;s Manual.  The Linux implementation of this interface may differ</span><br><span class="line">       (consult the corresponding Linux manual page for details of Linux behavior), or the interface may not be implemented</span><br><span class="line">       on Linux.</span><br><span class="line"></span><br><span class="line">NAME</span><br><span class="line">       fcntl - file control</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       #include &lt;unistd.h&gt;</span><br><span class="line">       #include &lt;fcntl.h&gt;</span><br><span class="line"></span><br><span class="line">       int fcntl(int fildes, int cmd, ...);</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">       The  fcntl()  function  shall  perform  the  operations described below on open files. The fildes argument is a file</span><br><span class="line">       descriptor.</span><br><span class="line"></span><br><span class="line">       The available values for cmd are defined in &lt;fcntl.h&gt; and are as follows:</span><br><span class="line"></span><br><span class="line">F_DUPFD//复制文件描述符</span><br><span class="line">	Return a new file descriptor which shall be the lowest numbered available (that is, not  already  open)  file descriptor  greater  than  or equal to the third argument, arg, taken as an integer of type int. The new file descriptor shall refer to the same open file description as the original file descriptor, and shall share any locks.  The  FD_CLOEXEC  flag  associated with the new file descriptor shall be cleared to keep the file open across calls to one of the exec functions.</span><br><span class="line"></span><br><span class="line">F_GETFD//获取文件描述符</span><br><span class="line">	Get the file descriptor flags defined in &lt;fcntl.h&gt; that are associated with the file descriptor fildes.  File descriptor  flags  are associated with a single file descriptor and do not affect other file descriptors that refer to the same file.</span><br><span class="line"></span><br><span class="line">F_SETFD//设置文件描述符</span><br><span class="line">	Set the file descriptor flags defined in &lt;fcntl.h&gt;, that are associated with fildes, to the  third  argument, arg,  taken as type int. If the FD_CLOEXEC flag in the third argument is 0, the file shall remain open across the exec functions; otherwise, the file shall be closed upon successful execution of one of  the  exec  func‐ tions.</span><br><span class="line"></span><br><span class="line">F_GETFL//获取文件状态标志</span><br><span class="line">	Get  the  file  status flags and file access modes, defined in &lt;fcntl.h&gt;, for the file description associated with fildes. The file access modes can be extracted from the return value using the mask O_ACCMODE, which  is defined in &lt;fcntl.h&gt;. File status flags and file access modes are associated with the file description and do not affect other file descriptors that refer to the same file with different open file descriptions.</span><br><span class="line"></span><br><span class="line">F_SETFL//设置文件状态标志</span><br><span class="line">	Set the file status flags, defined in &lt;fcntl.h&gt;, for the file description associated  with  fildes  from  the corresponding  bits in the third argument, arg, taken as type int. Bits corresponding to the file access mode and the file creation flags, as defined in &lt;fcntl.h&gt;, that are set in arg shall be ignored. If  any  bits  in arg other than those mentioned here are changed by the application, the result is unspecified.</span><br><span class="line"></span><br><span class="line">F_GETOWN//获取当前接收SIGIO和SIGURG信号的进程嗯IO和进程组ID</span><br><span class="line">	If  fildes  refers  to a socket, get the process or process group ID specified to receive SIGURG signals when out-of-band data is available. Positive values indicate a process ID; negative values, other than  -1,  indi‐cate a process group ID. If fildes does not refer to a socket, the results are unspecified.</span><br><span class="line"></span><br><span class="line">F_SETOWN//设置当前接收SIGIO和SIGURG信号的进程嗯IO和进程组ID</span><br><span class="line">        If  fildes  refers  to a socket, set the process or process group ID specified to receive SIGURG signals when out-of-band data is available, using the value of the third argument, arg, taken as type int. Positive values indicate  a process ID; negative values, other than -1, indicate a process group ID. If fildes does not refer to a socket, the results are unspecified.</span><br><span class="line"></span><br><span class="line">       The following values for cmd are available for advisory record locking. Record locking shall be supported for  regular files, and may be supported for other files.</span><br><span class="line">      </span><br><span class="line">F_GETLK//获取文件锁</span><br><span class="line">	Get  the  first  lock  which  blocks  the  lock description pointed to by the third argument, arg, taken as a pointer to type struct flock, defined in &lt;fcntl.h&gt;. The information retrieved shall overwrite the information passed  to  fcntl()  in the structure flock. If no lock is found that would prevent this lock from being created, then the structure shall be left unchanged except for the lock type which shall be set to F_UNLCK.</span><br><span class="line"></span><br><span class="line">F_SETLK//设置文件锁</span><br><span class="line">	Set or clear a file segment lock according to the lock description pointed to by  the  third  argument,  arg, taken  as  a pointer to type struct flock, defined in &lt;fcntl.h&gt;. F_SETLK can establish shared (or read) locks (F_RDLCK) or exclusive (or write) locks (F_WRLCK), as well as  to  remove  either  type  of  lock  (F_UNLCK). F_RDLCK, F_WRLCK, and F_UNLCK are defined in &lt;fcntl.h&gt;.  If a shared or exclusive lock cannot be set, fcntl() shall return immediately with a return value of -1.</span><br><span class="line"></span><br><span class="line">F_SETLKW//与F_SETLK设置文件锁类似，不过等待返回</span><br><span class="line">	This command shall be equivalent to F_SETLK except that if a shared or exclusive lock  is  blocked  by  other locks, the thread shall wait until the request can be satisfied. If a signal that is to be caught is received while fcntl() is waiting for a region, fcntl() shall be interrupted. Upon return  from  the  signal  handler, fcntl() shall return -1 with errno set to [EINTR], and the lock operation shall not be done.</span><br></pre></td></tr></table></figure>


<h2 id="read-timeout函数封装"><a href="#read-timeout函数封装" class="headerlink" title="read_timeout函数封装"></a>read_timeout函数封装</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">int read_timeout(int fd, unsinged int wait_seconds)</span><br><span class="line">&#123;</span><br><span class="line">        int ret = 0;</span><br><span class="line">        if(wait_seconds &gt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">                fd_set rset;</span><br><span class="line">                FD_ZERO(&amp;rset);</span><br><span class="line">                FD_SET(fd, &amp;rset);//把fd添加到集合当中</span><br><span class="line">                struct timeval time;</span><br><span class="line">                time.tv_sec = wait_seconds;</span><br><span class="line">                time_tv_usec = 0;</span><br><span class="line">                do</span><br><span class="line">                &#123;       //超时检测，时间到了，却未发生可读事件，返回0</span><br><span class="line">                        ret = select(fd + 1, &amp;rset, NULL, NULL, &amp;timeout);</span><br><span class="line">                &#125;while(ret &lt; 0 &amp;&amp; errno == EINTR);//中断后重启</span><br><span class="line">                //如果ret &lt; 0 则说明select函数是被中断的</span><br><span class="line">                //errno是记录程序的最后一次错误代码</span><br><span class="line">                //EINTR:当阻塞于某个慢系统调用的一个进程捕获某个信号且相应信号处理函数返回时，该系统调用可能返回一个EINTR错误。（查看网络编程的day09）</span><br><span class="line">                if(ret == 0)</span><br><span class="line">                &#123;</span><br><span class="line">                        ret = -1;</span><br><span class="line">                        errno = ETIMEOUT;</span><br><span class="line">                &#125;</span><br><span class="line">                else if(ret == 1)</span><br><span class="line">                &#123;</span><br><span class="line">                        ret = 1;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="剩下三个函数的封装"><a href="#剩下三个函数的封装" class="headerlink" title="剩下三个函数的封装"></a>剩下三个函数的封装</h2><blockquote>
<p>剩下的三个函数的封装在下载文件中，<code>write_timeout</code>和<code>read_timeout</code>类似，其他两个有所不同</p>
</blockquote>
<p><a href="./Download/day11.tar.gz"><font color="red" size=4> 点击下载源文件</font></a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/01/19/Socket/day11/" data-id="cm3mpi62c0031l0yadb541m7n" data-title="11 套接字IO超时设置&amp;errno&amp;fcntl&amp;getsockopt" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/socket/" rel="tag">socket</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Socket/day12" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/01/19/Socket/day12/" class="article-date">
  <time class="dt-published" datetime="2022-01-18T16:00:00.000Z" itemprop="datePublished">2022-01-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Socket/">Socket</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/01/19/Socket/day12/">12 select函数&amp;getrlimit&amp;setrlimit&amp;poll函数</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="day12"><a href="#day12" class="headerlink" title="day12"></a>day12</h1><h2 id="本章目标"><a href="#本章目标" class="headerlink" title="本章目标"></a>本章目标</h2><ul>
<li><code>select</code>限制</li>
<li><code>poll</code>，也是<code>I/O</code>复用函数</li>
</ul>
<h2 id="select限制"><a href="#select限制" class="headerlink" title="select限制"></a>select限制</h2><ul>
<li><p>用<code>select</code>实现的并发服务器，能达到的并发数，受两方面的限制</p>
<ul>
<li><p>一个进程所能打开的最大文件描述符限制，可以通过调整内核参数来改变，<code>ulimit -n</code>查看能打开的文件描描述符的大小，通过<code>ulimit -n num</code>：通过这条命令修改一个文件所能打开的最大文件描述符的限制，<code>num</code>为改变之后的最大文件描述符。这个命令只是临时修改，如果需要开机的时候改变的话则需要修改配置文件。</p>
<blockquote>
<p>发现几个<code>ulimit</code>的小坑，以下皆为个人猜想，有一定的实践操作佐证。</p>
<p><code>ulimit -n num</code>：如果是普通用户每次修改的文件描述符的<code>num</code>必须小于<code>ulimit -n</code>的数值的大小，否则会报错误<code>bash: ulimit: open files: cannot modify limit: Operation not permitted</code>，权限不够，emmm。如果是管理员则不会出现这个错误，可以修改成功。</p>
<p>即：管理员可以随意的改大改小，而普通用户只能不断的改小，不能改的比原来的最大能打开的文件描述符数量大。但是可以越改越小… …。</p>
<p>今天下午又试了一次发现普通用户也可以把最大能打开的文件描述符数量增大。… …. </p>
</blockquote>
</li>
<li><p><code>select</code>中的<code>fd_set</code>集合容量的限制(FD_SETSIZE，一般为1024)，这个需要重新编译内核。</p>
</li>
</ul>
</li>
</ul>
<h2 id="这里是一条插播的关于vim内容"><a href="#这里是一条插播的关于vim内容" class="headerlink" title="这里是一条插播的关于vim内容"></a>这里是一条插播的关于vim内容</h2><blockquote>
<p>参考文档：</p>
<p>​	<a target="_blank" rel="noopener" href="https://baike.1688.com/doc/view-d36947406.html">https://baike.1688.com/doc/view-d36947406.html</a></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">TAB就是制表符,单独拿出来做一节是因为这个东西确实很有用.</span><br><span class="line">    &gt;                 输入此命令则光标所在行向右移动一个tab.</span><br><span class="line">    5&gt;&gt;                输入此命令则光标后5行向右移动一个tab.</span><br><span class="line">    :12,24&gt;            此命令将12行到14行的数据都向右移动一个tab.</span><br><span class="line">    :12,24&gt;&gt;           此命令将12行到14行的数据都向右移动两个tab.</span><br><span class="line">    那么如何定义tab的大小呢?有人愿意使用8个空格位,有人用4个,有的用2个.</span><br><span class="line">    有的人希望tab完全用空格代替,也有的人希望tab就是tab.没关系,vim能</span><br><span class="line">    帮助您.以下的配置一般也都先写入配置文档中,免得老敲.</span><br><span class="line">    :set shiftwidth=4  配置自动缩进4个空格,当然要设自动缩进先.</span><br><span class="line">    :set sts=4         即配置softtabstop为4.输入tab后就跳了4格.</span><br><span class="line">    :set tabstop=4     实际的tab即为4个空格,而不是缺省的8个.</span><br><span class="line">    :set expandtab     在输入tab后,vim用恰当的空格来填充这个tab.</span><br><span class="line">命令模式</span><br><span class="line">  	dG从前行一直删除到文件末尾。</span><br><span class="line">	u：撤销操作，类似win的ctrl + z</span><br><span class="line">	ctrl + r:重做上一个操作</span><br></pre></td></tr></table></figure>

<h2 id="getrlimit和setrlimit"><a href="#getrlimit和setrlimit" class="headerlink" title="getrlimit和setrlimit"></a>getrlimit和setrlimit</h2><blockquote>
<p>获取一个进程所能打开的最大文件描述符数目。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/time.h&gt;</span><br><span class="line">#include &lt;sys/resource.h&gt;</span><br><span class="line"></span><br><span class="line">int getrlimit(int resource, struct rlimit *rlim);</span><br><span class="line">int setrlimit(int resource, const struct rlimit *rlim);</span><br><span class="line">int prlimit(pid_t pid, int resource, const struct rlimit *new_limit, struct rlimit *old_limit);</span><br><span class="line"></span><br><span class="line">resource:这里是获取进程能够打开的最大文件描述符个数，所以第一个参数为，RLIMIT_NOFILE。</span><br><span class="line">RLIMIT_NOFILE</span><br><span class="line">	Specifies a value one greater than the maximum file descriptor number that can be  opened  by  this  process. Attempts  (open(2), pipe(2), dup(2), etc.)  to exceed this limit yield the error EMFILE.  (Historically, this limit was named RLIMIT_OFILE on BSD.)</span><br><span class="line"></span><br><span class="line">第二个参数的结构体：使用时自己不需要再定义了。</span><br><span class="line">    struct rlimit &#123;</span><br><span class="line">        rlim_t rlim_cur;  /* Soft limit */</span><br><span class="line">        rlim_t rlim_max;  /* Hard limit (ceiling for rlim_cur) */</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">RETURN VALUE</span><br><span class="line">       On success, these system calls return 0.  On error, -1 is returned, and errno is set appropriately.</span><br></pre></td></tr></table></figure>

<h2 id="getrlimit和setrlimit函数使用代码"><a href="#getrlimit和setrlimit函数使用代码" class="headerlink" title="getrlimit和setrlimit函数使用代码"></a>getrlimit和setrlimit函数使用代码</h2><blockquote>
<p>如果提示权限不够则使用管理员运行。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;          /* See NOTES */</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;sys/time.h&gt;</span><br><span class="line">#include &lt;sys/resource.h&gt;</span><br><span class="line"></span><br><span class="line">#define ERR_EXIT(err) &#123;perror(err); exit(EXIT_FAILURE);&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">        struct rlimit limit;</span><br><span class="line">        if(-1 == getrlimit(RLIMIT_NOFILE, &amp;limit))//获取本进程limit信息</span><br><span class="line">        &#123;</span><br><span class="line">                ERR_EXIT(&quot;getrlimit&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;old: current = %lld max = %lld\n&quot;, limit.rlim_cur, limit.rlim_max);</span><br><span class="line"></span><br><span class="line">        limit.rlim_cur = 2048;</span><br><span class="line">        limit.rlim_max = 2048;</span><br><span class="line"></span><br><span class="line">        if(-1 == setrlimit(RLIMIT_NOFILE, &amp;limit))//重新设置</span><br><span class="line">        &#123;</span><br><span class="line">                ERR_EXIT(&quot;setrlimit&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if(-1 == getrlimit(RLIMIT_NOFILE, &amp;limit))//获取修改后的信息</span><br><span class="line">        &#123;</span><br><span class="line">                ERR_EXIT(&quot;getrlimit&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;new: current = %lld max = %lld\n&quot;, limit.rlim_cur, limit.rlim_max);</span><br><span class="line"></span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="测试一个进程可以打开的最大文件文件描述符"><a href="#测试一个进程可以打开的最大文件文件描述符" class="headerlink" title="测试一个进程可以打开的最大文件文件描述符"></a>测试一个进程可以打开的最大文件文件描述符</h2><blockquote>
<p>实际上<code>tag</code>只能到<code>1021</code>(ulimit 设置为1024时)。</p>
<p>why？？？，因为还有三个系统已经给你打开的<code>标准输入0</code>、<code>标准输出1</code>和<code>标准错误2</code>。加起来刚好<code>1024</code>个。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;          /* See NOTES */</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;sys/select.h&gt;</span><br><span class="line"></span><br><span class="line">#define ERR_EXIT(err) &#123;perror(err); exit(EXIT_FAILURE);&#125;</span><br><span class="line"></span><br><span class="line">//只作连接操作</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">        int tag = 0;</span><br><span class="line">        while(1)</span><br><span class="line">        &#123;</span><br><span class="line">                int sock;</span><br><span class="line">                int i = 0;</span><br><span class="line">                struct sockaddr_in servaddr;//一个服务器的地址</span><br><span class="line"></span><br><span class="line">                sock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">                if(sock &lt; 0)</span><br><span class="line">                &#123;</span><br><span class="line">                        perror(&quot;创建scoket失败\n&quot;);</span><br><span class="line">                        exit(EXIT_FAILURE);//退出程序</span><br><span class="line">                &#125;</span><br><span class="line">                memset(&amp;servaddr, 0, sizeof(servaddr));//初始化地址</span><br><span class="line">                servaddr.sin_family = AF_INET;//地址族</span><br><span class="line">                servaddr.sin_port = htons(6000);//端口号，网络字节序转化为主机字节序</span><br><span class="line">                servaddr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;);//指定服务端的地址</span><br><span class="line"></span><br><span class="line">                int conn = -1;</span><br><span class="line">                if((conn = connect(sock, (struct sockaddr *)&amp;servaddr, sizeof(servaddr)) &lt; 0))</span><br><span class="line">                &#123;</span><br><span class="line">                        printf(&quot;连接服务器失败\n&quot;);</span><br><span class="line">                        exit(EXIT_FAILURE);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                //获取本地的地址</span><br><span class="line">                struct sockaddr_in sockname;</span><br><span class="line">                socklen_t addrlen = sizeof(sockname);</span><br><span class="line">                if(0 &gt; getsockname(sock, (struct sockaddr *)&amp;sockname, (socklen_t *)&amp;addrlen))</span><br><span class="line">                &#123;</span><br><span class="line">                        perror(&quot;getsockname&quot;);</span><br><span class="line">                        exit(EXIT_FAILURE);//退出程序</span><br><span class="line">                &#125;</span><br><span class="line">                tag++;</span><br><span class="line">                printf(&quot;%d\n&quot;, tag);</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>部分程序运行结果(客户端)：这个结果有一定的问题，但也是正确的，请仔细阅读理解下面的对于这个原因的解释。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1019</span><br><span class="line">1020</span><br><span class="line">1021</span><br><span class="line">创建scoket失败</span><br><span class="line">: Too many open files</span><br><span class="line">[pip@localhost code]$ </span><br></pre></td></tr></table></figure>
<p>服务器端理论应该为：<code>1020</code>个，因为不仅有<code>标准输入0</code>、<code>标准输出1</code>和<code>标准错误2</code>，还有一个监听套接<code>listenfd</code>占用了一个文件描述符。则最多接受<code>1020</code>个连接了。如果服务端一直保持不断开的话。那么客户端也只能连接<code>1020</code>个，但是由于服务器与客户端的链接关闭了，导致可以连接客户端多于<code>1020个</code>了。所以上面的客户端的运行结果有一定的问题，服务器的对客户端处理合适，客户端的最大连接到服务器的个数为<code>1020</code>个,短板效应。</p>
</blockquote>
<h2 id="poll函数"><a href="#poll函数" class="headerlink" title="poll函数"></a>poll函数</h2><blockquote>
<p>也是并发服务器的函数，与<code>select</code>类似</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;poll.h&gt;</span><br><span class="line"></span><br><span class="line">int poll(struct pollfd *fds, nfds_t nfds, int timeout);</span><br><span class="line"></span><br><span class="line">struct pollfd &#123;</span><br><span class="line">    int   fd;         /* file descriptor */</span><br><span class="line">    short events;     /* requested events */</span><br><span class="line">    short revents;    /* returned events */</span><br><span class="line">&#125;;</span><br><span class="line">结构体的成员变量events：</span><br><span class="line">The bits that may be set/returned in events and revents are defined in &lt;poll.h&gt;:</span><br><span class="line"></span><br><span class="line">POLLIN //有数据可读时</span><br><span class="line">	There is data to read.</span><br><span class="line">POLLPRI</span><br><span class="line">	There  is  urgent  data  to read (e.g., out-of-band data on TCP socket; pseudoterminal master in packet mode has seen state change in slave).</span><br><span class="line"></span><br><span class="line">POLLOUT</span><br><span class="line">	Writing now will not block.</span><br><span class="line"></span><br><span class="line">POLLRDHUP (since Linux 2.6.17)</span><br><span class="line">	Stream socket peer closed connection, or shut down writing half of connection.   The  _GNU_SOURCE  feature  test macro must be defined (before including any header files) in order to obtain this definition.</span><br><span class="line"></span><br><span class="line">POLLERR</span><br><span class="line">	Error condition (output only).</span><br><span class="line"></span><br><span class="line">POLLHUP</span><br><span class="line">	Hang up (output only).</span><br><span class="line"></span><br><span class="line">POLLNVAL</span><br><span class="line">	Invalid request: fd not open (output only).</span><br></pre></td></tr></table></figure>


<p>##struct pollfd的events附录</p>
<p><img src="/./Picture/poll_events.png" alt="poll_events"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/01/19/Socket/day12/" data-id="cm3mpi62c0033l0yah0e57el1" data-title="12 select函数&amp;getrlimit&amp;setrlimit&amp;poll函数" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/select%E5%87%BD%E6%95%B0/" rel="tag">select函数</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Socket/day14" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/01/19/Socket/day14/" class="article-date">
  <time class="dt-published" datetime="2022-01-18T16:00:00.000Z" itemprop="datePublished">2022-01-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Socket/">Socket</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/01/19/Socket/day14/">14 UDP服务器</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="day14"><a href="#day14" class="headerlink" title="day14"></a>day14</h1><h2 id="本章目标"><a href="#本章目标" class="headerlink" title="本章目标"></a>本章目标</h2><ul>
<li><code>UDP</code>特点</li>
<li><code>UDP</code>客户&#x2F;服务基本模型</li>
<li><code>UDP</code>回射客户&#x2F;服务器</li>
<li><code>UDP</code>注意点</li>
</ul>
<h2 id="UDP特点"><a href="#UDP特点" class="headerlink" title="UDP特点"></a>UDP特点</h2><ul>
<li>无连接</li>
<li>基于消息的数据传输服务，理解为数据包之间有边界。</li>
<li>不可靠</li>
<li>一般情况下UDP更加高效</li>
</ul>
<h2 id="UDP注意点"><a href="#UDP注意点" class="headerlink" title="UDP注意点"></a>UDP注意点</h2><ul>
<li><code>UDP</code>报文可能会丢失、重复</li>
<li><code>UDP</code>报文可能会乱序</li>
<li><code>UDP</code>缺乏流量控制</li>
<li><code>UDP</code>协议数据报文截断</li>
<li><code>recvfrom</code>返回为0，不代表连接关闭，因为<code>UDP是无连接的</code></li>
<li><code>ICMP</code>异步错误</li>
<li><code>UDP connect</code></li>
<li><code>UDP</code>外出接口的确定</li>
</ul>
<h2 id="echosrv-c"><a href="#echosrv-c" class="headerlink" title="echosrv.c"></a>echosrv.c</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">#define ERR_EXIT(x) do&#123;perror(x); exit(EXIT_FAILURE);&#125;while(0)</span><br><span class="line"></span><br><span class="line">void echo_srv(int sock)</span><br><span class="line">&#123;</span><br><span class="line">	int ret = 0;</span><br><span class="line">	char recvbuf[1024] = &#123;0&#125;;</span><br><span class="line">	struct sockaddr_in peeraddr;</span><br><span class="line">	socklen_t peerlen = sizeof(peeraddr);</span><br><span class="line">	while(1)</span><br><span class="line">	&#123;</span><br><span class="line">		memset(recvbuf, 0, sizeof(recvbuf));</span><br><span class="line">		ret = recvfrom(sock, recvbuf, 1024, 0, (struct sockaddr *)&amp;peeraddr, &amp;peerlen);</span><br><span class="line">		if(ret &lt; 0)</span><br><span class="line">		&#123;</span><br><span class="line">			if(errno == EINTR)</span><br><span class="line">				continue;</span><br><span class="line">			ERR_EXIT(&quot;recvfrom&quot;);</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		else if(ret &gt; 0)</span><br><span class="line">		&#123;</span><br><span class="line">			fputs(recvbuf, stdout);</span><br><span class="line">			sendto(sock, recvbuf, strlen(recvbuf), 0, (struct sockaddr *)&amp;peeraddr, peerlen);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	close(sock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int sock = 0;</span><br><span class="line">	sock = socket(PF_INET, SOCK_DGRAM, 0);//参数一表示为IPV4地址家族，第二个参数IPV4对应的UDP套接口，第三个参数0表示内核自动选择协议根据前两个可以确定通信协议为UDP的</span><br><span class="line">	if(sock &lt; 0)</span><br><span class="line">	&#123;</span><br><span class="line">		ERR_EXIT(&quot;socket&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	struct sockaddr_in servaddr;</span><br><span class="line">	memset(&amp;servaddr, 0, sizeof(servaddr));</span><br><span class="line">	servaddr.sin_family = AF_INET;</span><br><span class="line">	servaddr.sin_port = 6000;</span><br><span class="line">	//servaddr.sin_addr = htonl(&quot;127.0.0.1&quot;);//和下面的一样作用，绑定指定的地址，和绑定任意一个地址。</span><br><span class="line">	servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">	if(bind(sock, (struct sockaddr *)&amp;servaddr, sizeof(servaddr)) &lt; 0)</span><br><span class="line">		ERR_EXIT(&quot;bind&quot;);</span><br><span class="line">	//不需要监听，直接连接的。</span><br><span class="line">	echo_srv(sock);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="echocli-c"><a href="#echocli-c" class="headerlink" title="echocli.c"></a>echocli.c</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">#define ERR_EXIT(x) do&#123;perror(x); exit(EXIT_FAILURE);&#125;while(0)</span><br><span class="line"></span><br><span class="line">void echo_cli(int sock)</span><br><span class="line">&#123;</span><br><span class="line">	struct sockaddr_in servaddr;</span><br><span class="line">        memset(&amp;servaddr, 0, sizeof(servaddr));</span><br><span class="line">        servaddr.sin_family = AF_INET;</span><br><span class="line">        servaddr.sin_port = 6000;</span><br><span class="line">	servaddr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;);//绑定服务器地址</span><br><span class="line">	if(connect(sock, (struct sockaddr *)&amp;servaddr, sizeof(servaddr)) &lt; 0)//连接后只能给指定的IP发送数据，则sendto可以不需要指定IP和端口了,UDP的connect是进行了一个弱绑定，不会进行三次握手和四次挥手</span><br><span class="line">		ERR_EXIT(&quot;connect&quot;);</span><br><span class="line">	int ret = 0;</span><br><span class="line">	char sendbuf[1024] = &#123;0&#125;;</span><br><span class="line">	char recvbuf[1024] = &#123;0&#125;;</span><br><span class="line">	while(1)</span><br><span class="line">	&#123;</span><br><span class="line">		memset(sendbuf, 0, sizeof(sendbuf));</span><br><span class="line">		memset(recvbuf, 0, sizeof(recvbuf));</span><br><span class="line">		if(fgets(sendbuf, sizeof(sendbuf), stdin) == NULL)</span><br><span class="line">			ERR_EXIT(&quot;fgets&quot;);</span><br><span class="line">		//sendto(sock, sendbuf, strlen(sendbuf), 0, NULL, 0);</span><br><span class="line">		send(sock, sendbuf, strlen(sendbuf), 0);</span><br><span class="line">		ret = recvfrom(sock, recvbuf, sizeof(recvbuf), 0, NULL, NULL);</span><br><span class="line">		if(ret &lt; 0)</span><br><span class="line">		&#123;</span><br><span class="line">			if(errno == EINTR)</span><br><span class="line">				continue;</span><br><span class="line">			ERR_EXIT(&quot;recvbrom&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		fputs(recvbuf, stdout);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int sock = 0;</span><br><span class="line">	sock = socket(PF_INET, SOCK_DGRAM, 0);//参数一表示为IPV4地址家族，第二个参数IPV4对应的UDP套接口，第三个参数0表示内核自动选择协议根据前两个可以确定通信协议为UDP的</span><br><span class="line">	if(sock &lt; 0)</span><br><span class="line">	&#123;</span><br><span class="line">		ERR_EXIT(&quot;socket&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	echo_cli(sock);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/01/19/Socket/day14/" data-id="cm3mpi62d0037l0yaclt3gqim" data-title="14 UDP服务器" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/UDP%E5%9B%9E%E5%B0%84%E5%AE%A2%E6%88%B7%E7%AB%AF/" rel="tag">UDP回射客户端</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/UDP%E6%9C%8D%E5%8A%A1%E5%99%A8/" rel="tag">UDP服务器</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Socket/day13" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/01/19/Socket/day13/" class="article-date">
  <time class="dt-published" datetime="2022-01-18T16:00:00.000Z" itemprop="datePublished">2022-01-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Socket/">Socket</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/01/19/Socket/day13/">13 epoll相关函数、select、epoll和poll区别</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="day13"><a href="#day13" class="headerlink" title="day13"></a>day13</h1><h2 id="本章目标"><a href="#本章目标" class="headerlink" title="本章目标"></a>本章目标</h2><ul>
<li><code>epoll</code>使用</li>
<li><code>epoll</code>与<code>select</code>、<code>poll</code>区别</li>
<li><code>epoll LR/ET</code>模式</li>
</ul>
<h2 id="复习select和poll"><a href="#复习select和poll" class="headerlink" title="复习select和poll"></a>复习select和poll</h2><ul>
<li><p><code>select</code></p>
<ul>
<li>一个进程能打开的最大文件描述符个数是有限的</li>
<li>FD_SETSIZE的限制</li>
</ul>
</li>
<li><p><code>poll</code></p>
<ul>
<li><p>一个进程能打开的最大文件描述符个数是有限的，系统能打开的最大文件描述符个数是有限的，与系统内存有关<code>cat /proc/sys/fs/file-max</code>，查看系统能打开的最大的文件描述符的个数。</p>
<blockquote>
<p><code>ulimit -n num</code></p>
</blockquote>
</li>
</ul>
</li>
<li><p>共同点：</p>
<blockquote>
<p>内核需要遍历所有的文件描述符，直到找到发生事件的文件描述符。—&gt;提高效率点，<code>epoll</code>对此进行了优化</p>
</blockquote>
</li>
</ul>
<h2 id="epoll相关函数"><a href="#epoll相关函数" class="headerlink" title="epoll相关函数"></a>epoll相关函数</h2><ul>
<li><code>int epoll_create(int size);</code>&#x2F;&#x2F;创建一个<code>epoll</code>实例,使用哈希表存储的,size是内部创建的哈希表大小</li>
<li><code>int epoll_create1(int flags);</code>&#x2F;&#x2F;同上,使用的是红黑数,所以不再需要指定大小了.—&gt;优先选择使用.</li>
<li><code>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);</code>&#x2F;&#x2F;把一个套接字添加到实例中,进行管理</li>
<li><code>int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);</code>&#x2F;&#x2F;等待事件</li>
</ul>
<blockquote>
<p><code>man 2 epoll_create</code></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">SYNOPSIS</span><br><span class="line">    #include &lt;sys/epoll.h&gt;</span><br><span class="line"></span><br><span class="line">    int epoll_create(int size);</span><br><span class="line">    int epoll_create1(int flags);</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">	epoll_create()  creates  an  epoll(7)  instance.   Since  Linux 2.6.8, the size argument is ignored, but must be greater than zero; see NOTES below.</span><br><span class="line">	epoll_create() returns a file descriptor referring to the new epoll  instance.   This  file descriptor  is  used  for  all the subsequent calls to the epoll interface.  When no longer required, the file  descriptor  returned  by  epoll_create()  should  be  closed  by  using close(2).   When  all file descriptors referring to an epoll instance have been closed, the kernel destroys the instance and releases the associated resources for reuse.</span><br><span class="line"></span><br><span class="line">epoll_create1()</span><br><span class="line">	If flags is 0, then, other than the fact  that  the  obsolete  size  argument  is  dropped, epoll_create1()  is  the  same  as  epoll_create().  The following value can be included in flags to obtain different behavior:</span><br><span class="line"></span><br><span class="line">EPOLL_CLOEXEC</span><br><span class="line">	Set the close-on-exec (FD_CLOEXEC)  flag  on  the  new  file  descriptor.   See  the description of the O_CLOEXEC flag in open(2) for reasons why this may be useful.</span><br><span class="line"></span><br><span class="line">RETURN VALUE</span><br><span class="line">	On  success,  these  system  calls  return  a nonnegative file descriptor.  On error, -1 is returned, and errno is set to indicate the error.</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>man 2 epoll_ctl</code></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">SYNOPSIS</span><br><span class="line">       #include &lt;sys/epoll.h&gt;</span><br><span class="line"></span><br><span class="line">       int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">       This system call performs control operations on the epoll(7) instance referred to by the file descriptor epfd.  It requests that the operation op be performed for the target file descriptor, fd.</span><br><span class="line"></span><br><span class="line">Valid values for the op argument are :</span><br><span class="line"></span><br><span class="line">EPOLL_CTL_ADD</span><br><span class="line">	Register the target file descriptor fd on the epoll instance referred to by the  file  descriptor epfd and associate the event event with the internal file linked to fd.</span><br><span class="line"></span><br><span class="line">EPOLL_CTL_MOD</span><br><span class="line">	Change the event event associated with the target file descriptor fd.</span><br><span class="line"></span><br><span class="line">EPOLL_CTL_DEL</span><br><span class="line">	Remove  (deregister)  the  target file descriptor fd from the epoll instance referred to by epfd. The event is ignored and can be NULL (but see BUGS below). The event argument describes the object linked to the file descriptor fd.   The  struct  epoll_event  is defined as :</span><br><span class="line">	</span><br><span class="line">    typedef union epoll_data &#123;</span><br><span class="line">        void        *ptr;</span><br><span class="line">        int          fd;</span><br><span class="line">        uint32_t     u32;</span><br><span class="line">        uint64_t     u64;</span><br><span class="line">    &#125; epoll_data_t;</span><br><span class="line"></span><br><span class="line">    struct epoll_event &#123;</span><br><span class="line">        uint32_t     events;      /* Epoll events */</span><br><span class="line">        epoll_data_t data;        /* User data variable */</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">//epoll_event成员events的参数</span><br><span class="line">The events member is a bit set composed using the following available event types:</span><br><span class="line"></span><br><span class="line">EPOLLIN</span><br><span class="line">	The associated file is available for read(2) operations.</span><br><span class="line"></span><br><span class="line">EPOLLOUT</span><br><span class="line">	The associated file is available for write(2) operations.</span><br><span class="line"></span><br><span class="line">EPOLLRDHUP (since Linux 2.6.17)</span><br><span class="line">	Stream  socket  peer  closed  connection, or shut down writing half of connection.  (This flag is especially useful for writing simple code to detect peer shutdown when using Edge Triggered monitoring.)</span><br><span class="line"></span><br><span class="line">EPOLLPRI</span><br><span class="line">	There is urgent data available for read(2) operations.</span><br><span class="line"></span><br><span class="line">EPOLLERR</span><br><span class="line">	Error  condition  happened on the associated file descriptor.  epoll_wait(2) will always wait for this event; it is not necessary to set it in events.</span><br><span class="line"></span><br><span class="line">EPOLLHUP</span><br><span class="line">	Hang up happened on the associated file descriptor.  epoll_wait(2)  will  always  wait  for  this event; it is not necessary to set it in events.</span><br><span class="line"></span><br><span class="line">EPOLLET</span><br><span class="line">	Sets  the  Edge  Triggered behavior for the associated file descriptor.  The default behavior for epoll is Level Triggered.  See epoll(7) for more detailed information about Edge and Level  Triggered event distribution architectures.</span><br><span class="line"></span><br><span class="line">EPOLLONESHOT (since Linux 2.6.2)</span><br><span class="line">	Sets the one-shot behavior for the associated file descriptor.  This means that after an event is pulled out with epoll_wait(2) the associated file descriptor is internally disabled and no  other events  will  be  reported  by  the  epoll  interface.   The  user  must  call  epoll_ctl()  with EPOLL_CTL_MOD to rearm the file descriptor with a new event mask.</span><br></pre></td></tr></table></figure>



<blockquote>
<p><code>man 2 epoll_wait</code></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">SYNOPSIS</span><br><span class="line">	#include &lt;sys/epoll.h&gt;</span><br><span class="line"></span><br><span class="line">	int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);</span><br><span class="line">	int epoll_pwait(int epfd, struct epoll_event *events,int maxevents, int timeout, const sigset_t *sigmask);</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">	The  epoll_wait()  system call waits for events on the epoll(7) instance referred to by the file descriptor epfd.  The memory area pointed to by events will contain  the  events  that will  be available for the caller.  Up to maxevents are returned by epoll_wait().  The maxevents argument must be greater than zero.</span><br><span class="line"></span><br><span class="line">	The timeout argument specifies the minimum number of milliseconds  that  epoll_wait()  will block.   (This  interval  will  be  rounded  up to the system clock granularity, and kernel scheduling delays mean that the blocking interval may overrun by a small amount.)  Specifying  a  timeout of -1 causes epoll_wait() to block indefinitely, while specifying a timeout equal to zero cause epoll_wait() to return immediately, even if no events are available.</span><br><span class="line"></span><br><span class="line">The struct epoll_event is defined as :</span><br><span class="line"></span><br><span class="line">    typedef union epoll_data &#123;</span><br><span class="line">        void    *ptr;</span><br><span class="line">        int      fd;</span><br><span class="line">        uint32_t u32;</span><br><span class="line">        uint64_t u64;</span><br><span class="line">    &#125; epoll_data_t;</span><br><span class="line"></span><br><span class="line">    struct epoll_event &#123;</span><br><span class="line">        uint32_t     events;    /* Epoll events */</span><br><span class="line">        epoll_data_t data;      /* User data variable */</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">	The data of each returned structure will contain  the  same  data  the  user  set  with  an epoll_ctl(2)  (EPOLL_CTL_ADD,EPOLL_CTL_MOD)  while  the  events  member  will  contain  the returned event bit field.</span><br></pre></td></tr></table></figure>

<h2 id="epoll实现并发服务器—-优"><a href="#epoll实现并发服务器—-优" class="headerlink" title="epoll实现并发服务器—&gt;优"></a>epoll实现并发服务器—&gt;优</h2><blockquote>
<p><code>epoll</code>实现服务器会占用五个套接字，<code>标准输入</code>、<code>标准输出</code>、<code>标准错误</code>、<code>服务器监听套接字</code>和<code>epoll的句柄</code>。剩下的，所以当进程的&#96;&#96;最大套接字的个数 - 5<code>，就是</code>epoll<code>可以连接的最大客户端个数了。</code>epoll<code>比</code>poll&#96;效率要高。 </p>
<p><font size=5><a href="./epollsrv.md">点击查看epollsrv代码</a></font></p>
</blockquote>
<h2 id="epoll、select和poll的区别"><a href="#epoll、select和poll的区别" class="headerlink" title="epoll、select和poll的区别"></a>epoll、select和poll的区别</h2><ul>
<li><p>相比于<code>select</code>与<code>poll</code>、<code>epoll</code>最大的好处载于它不会随着监听套接字<code>fd</code>数目的增多而降低效率。</p>
</li>
<li><p>内核中的<code>select</code>与<code>poll</code>的实现是采用轮询来处理的，轮询的<code>fd</code>数目越多，自然消耗时间越长</p>
</li>
<li><p><code>epoll</code>的实现是基于回调的，如果<code>fd</code>有期望的事件发生就通过回调函数将其加入<code>epoll</code>就绪队列中，也就是说它只关心<code>活跃</code>的fd，与<code>fd</code>的数目无关。</p>
</li>
<li><p><code>内核/用户空间</code> 内存拷贝问题，如何让内核把<code>fd</code>消息通知给用户空间呢？</p>
<blockquote>
<p>在这个问题上<code>select/poll</code>采用了内存拷贝方法，而<code>epoll</code>采用了共享内存的方法。</p>
</blockquote>
</li>
<li><p><code>epoll</code>不仅会告诉应用程序有<code>I/O</code>事件，还会告诉应用程序相关的信息，这些信息是应用程序填充的，因此根据这些信息应用程序就能直接定位到事件，而不必遍历整个<code>fd</code>集合了。</p>
</li>
</ul>
<blockquote>
<p>学后感！！！</p>
<p>个人感觉<code>epoll</code>的机制和<code>Qt的信号和槽</code>的处理机制很有共同点，这里说的是思想方面，不是底层代码的实现和一些细节性的问题，比如说Qt的信号和槽的设计思想，当有信号时，才会去调用槽(槽就是一回调函数的，入口指针)，节省了不停的轮巡遍历的操作，大大节省了CPU和内存的资源，因为你活跃起来了我再去处理你，否则的话，你就老老实实的待在哪里等信号。个人观点如有理解错误，请多多包含，同时希望可以指正。</p>
</blockquote>
<p>##epoll LT&#x2F;ET模式</p>
<ul>
<li><code>EPOLLLT</code>：电平触发模式</li>
<li><code>EPOLLET</code>：边沿触发模式，效率高。</li>
</ul>
<h2 id="EPOLLLT模式"><a href="#EPOLLLT模式" class="headerlink" title="EPOLLLT模式"></a>EPOLLLT模式</h2><blockquote>
<p>电平&#x2F;水平触发模式，完全靠<code>kernel epoll</code>驱动，应用程序只需要处理从<code>epoll_wait</code>返回的fds，这些<code>fds</code>我们认为它们处于就绪状态</p>
</blockquote>
<h2 id="EPOLLET模式"><a href="#EPOLLET模式" class="headerlink" title="EPOLLET模式"></a>EPOLLET模式</h2><blockquote>
<p>边沿触发模式，是一把双刃剑，如果处理不当可能会导致效率不如，<code>LT模式</code>。如果需要高效率，则程序员则需要更高的要求，来维护<code>ET模式</code></p>
<p>​	此模式下，系统仅通知应用程序那些<code>fds</code>变成了就绪状态，一旦<code>fd</code>变成就绪状态，<code>epoll</code>将不再关注这个<code>fd</code>的任何状态信息(从<code>epoll</code>队列中移除)，直到应用程序通过读写操作触发<code>EAGAIN</code>状态，<code>epoll</code>认为这个<code>fd</code>又变为空闲状态，那么<code>epoll</code>又重新关注这个<code>fd</code>的状态变话(添加到<code>epoll</code>队列中)</p>
<p>​	随着<code>epoll_wait</code>的返回，队列中的<code>fds</code>是在减少的，所以在大并发的系统中，<code>EPOLLET</code>模式更具有优势，但是对程序员的要求也变高了。（emmm， 这是什么鬼啊），程序员需要对程序维护，避免读取一部分数据后剩下数据无法读出导致阻塞。</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/01/19/Socket/day13/" data-id="cm3mpi62d003al0ya8lbp9565" data-title="13 epoll相关函数、select、epoll和poll区别" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/epoll%E4%BD%BF%E7%94%A8/" rel="tag">epoll使用</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/select-poll-epoll/" rel="tag">select&amp;poll&amp;epoll</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Socket/day16" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/01/19/Socket/day16/" class="article-date">
  <time class="dt-published" datetime="2022-01-18T16:00:00.000Z" itemprop="datePublished">2022-01-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Socket/">Socket</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/01/19/Socket/day16/">16 UNIX域协议学习</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="day16"><a href="#day16" class="headerlink" title="day16"></a>day16</h1><h2 id="本章目标"><a href="#本章目标" class="headerlink" title="本章目标"></a>本章目标</h2><ul>
<li><code>UNIX</code>域协议特点</li>
<li><code>UNIX</code>域地址结构</li>
<li><code>UNIX</code>域字节流回射客户&#x2F;服务</li>
<li><code>UNIX</code>域套接字编程注意点</li>
</ul>
<h2 id="UNIX域协议特点"><a href="#UNIX域协议特点" class="headerlink" title="UNIX域协议特点"></a>UNIX域协议特点</h2><ul>
<li><code>UNIX</code>域套接字与<code>TCP</code>套接字相比较，在同一台主机的传输速度前者是后者的两倍。</li>
<li><code>UNIX</code>域套接字可以在同一台主机上各进程之间传递描述符。</li>
<li><code>UNIX</code>域套接字与传统套接字的区别是用路径名来表示协议族的描述。</li>
</ul>
<h2 id="UNIX域地址结构"><a href="#UNIX域地址结构" class="headerlink" title="UNIX域地址结构"></a>UNIX域地址结构</h2><blockquote>
<p><code>man unix</code></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#define UNIX_PATH_MAX 108</span><br><span class="line">struct sockaddr_un</span><br><span class="line">&#123;</span><br><span class="line">    sa_family_t sun_family; //为AF_UNIX</span><br><span class="line">    char sun_path[UNIX_PATH_MAX]; //pathname</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>##UNIX域字节流回射客户&#x2F;服务</p>
<blockquote>
<p><code>echosrv.c</code></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;sys/un.h&gt;</span><br><span class="line"></span><br><span class="line">#define ERR_EXIT(x) do&#123;perror(x); exit(EXIT_FAILURE);&#125;while(0)</span><br><span class="line"></span><br><span class="line">void echo_srv(int conn)</span><br><span class="line">&#123;</span><br><span class="line">	int ret = 0;</span><br><span class="line">	char recvbuf[1024] = &#123;0&#125;;</span><br><span class="line">	while(1)</span><br><span class="line">	&#123;</span><br><span class="line">		memset(recvbuf, 0, sizeof(recvbuf));</span><br><span class="line">		ret = read(conn, recvbuf, sizeof(recvbuf));</span><br><span class="line">		if(ret &lt; 0)</span><br><span class="line">		&#123;</span><br><span class="line">			if(errno = EINTR)</span><br><span class="line">				continue;</span><br><span class="line">			 ERR_EXIT(&quot;read&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		else if(ret == 0)</span><br><span class="line">		&#123;</span><br><span class="line">			printf(&quot;对方关闭连接&quot;);</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		fputs(recvbuf, stdout);</span><br><span class="line">		ret = write(conn, recvbuf, strlen(recvbuf));</span><br><span class="line">	&#125;</span><br><span class="line">	close(conn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int conn;</span><br><span class="line">	int listenfd;</span><br><span class="line">	unlink(&quot;test_socket&quot;);//删除一个文件的目录项并减少它的链接数，若成功则返回0，否则返回-1，错误原因存于error。如果想通过调用这个函数来成功删除文件，你就必须拥有这个文件的所属目录的写和执行权</span><br><span class="line">	if((listenfd = socket(PF_UNIX, SOCK_STREAM, 0)) &lt; 0)</span><br><span class="line">		ERR_EXIT(&quot;socket&quot;);</span><br><span class="line">	struct sockaddr_un servaddr;</span><br><span class="line">	memset(&amp;servaddr, 0, sizeof(servaddr));</span><br><span class="line">	servaddr.sun_family = AF_UNIX;</span><br><span class="line">	strcpy(servaddr.sun_path, &quot;test_socket&quot;);</span><br><span class="line">	if(bind(listenfd, (struct sockaddr *)&amp;servaddr, sizeof(servaddr)) &lt; 0)	</span><br><span class="line">		ERR_EXIT(&quot;bind&quot;);</span><br><span class="line">	if(listen(listenfd, SOMAXCONN) &lt; 0)</span><br><span class="line">		ERR_EXIT(&quot;listen&quot;);</span><br><span class="line">	</span><br><span class="line">	pid_t pid;</span><br><span class="line">	while(1)</span><br><span class="line">	&#123;</span><br><span class="line">		conn = accept(listenfd, NULL, NULL);	</span><br><span class="line">		if(conn == -1)</span><br><span class="line">		&#123;</span><br><span class="line">			//用户态资源并没有准备好，返回EINTR错误。以便用户态可以做出自己的决定。</span><br><span class="line">			if(errno = EINTR)</span><br><span class="line">				continue;</span><br><span class="line">			ERR_EXIT(&quot;accept&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		pid = fork();</span><br><span class="line">		if(pid &lt; 0)</span><br><span class="line">			ERR_EXIT(&quot;fork&quot;);</span><br><span class="line">		else if(pid == 0)//子进程处理新的连接</span><br><span class="line">		&#123;</span><br><span class="line">			close(listenfd);//子进程不需要处理监听</span><br><span class="line">			echo_srv(conn);</span><br><span class="line">			exit(EXIT_SUCCESS);</span><br><span class="line">		&#125;</span><br><span class="line">		close(conn);//父进程不需要处理连接</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>echocli.c</code></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;sys/un.h&gt;</span><br><span class="line"></span><br><span class="line">#define ERR_EXIT(x) do&#123;perror(x); exit(EXIT_FAILURE);&#125;while(0)</span><br><span class="line"></span><br><span class="line">void echo_cli(int sock)</span><br><span class="line">&#123;</span><br><span class="line">	int ret = 0;</span><br><span class="line">	char sendbuf[1024] = &#123;0&#125;;</span><br><span class="line">	char recvbuf[1024] = &#123;0&#125;;</span><br><span class="line">	while(fgets(sendbuf, sizeof(sendbuf), stdin) != NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		ret = write(sock, sendbuf, sizeof(sendbuf));</span><br><span class="line">		ret = read(sock, recvbuf, sizeof(recvbuf));</span><br><span class="line">		fputs(recvbuf, stdout);</span><br><span class="line">		memset(sendbuf, 0, sizeof(sendbuf));</span><br><span class="line">		memset(recvbuf, 0, sizeof(recvbuf));</span><br><span class="line">	&#125;</span><br><span class="line">	close(sock);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int sock;</span><br><span class="line">	if((sock = socket(PF_UNIX, SOCK_STREAM, 0)) &lt; 0)</span><br><span class="line">		ERR_EXIT(&quot;socket&quot;);</span><br><span class="line">	struct sockaddr_un servaddr;</span><br><span class="line">	memset(&amp;servaddr, 0, sizeof(servaddr));</span><br><span class="line">	servaddr.sun_family = AF_UNIX;</span><br><span class="line">	strcpy(servaddr.sun_path, &quot;test_socket&quot;);</span><br><span class="line">	if(connect(sock, (struct sockaddr *)&amp;servaddr, sizeof(servaddr)) &lt; 0)</span><br><span class="line">		ERR_EXIT(&quot;connect&quot;);</span><br><span class="line">	</span><br><span class="line">	echo_cli(sock);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>##UNIX套接字编程注意点</p>
<ul>
<li><code>bind</code>成功将会创建一个文件，权限为<code>0777&amp;umask</code></li>
<li><code>sun_path</code>最好用一个绝对路径，一般定到<code>tmp</code>目录下。</li>
<li><code>UNIX</code>域协议支持流式接口<code>SOCK_STREAM</code>与报式套接口<code>SOCK_DGRAM</code></li>
<li><code>UNIX</code>域流式套接字<code>connect</code>发现监听队列满时，会立即返回一个<code>ECONNERFUSED</code>，这和<code>TCP</code>不同，如果监听套接字队列满，会忽略到来的<code>SYN</code>，导致对方重发<code>SYN</code>。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/01/19/Socket/day16/" data-id="cm3mpi62e003dl0yabf819kxv" data-title="16 UNIX域协议学习" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/UNIX%E5%9F%9F%E5%8D%8F%E8%AE%AE/" rel="tag">UNIX域协议</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Socket/day17" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/01/19/Socket/day17/" class="article-date">
  <time class="dt-published" datetime="2022-01-18T16:00:00.000Z" itemprop="datePublished">2022-01-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Socket/">Socket</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/01/19/Socket/day17/">17 socketpair、全双工流管道</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="day17"><a href="#day17" class="headerlink" title="day17"></a>day17</h1><h2 id="本章目标"><a href="#本章目标" class="headerlink" title="本章目标"></a>本章目标</h2><ul>
<li><code>socketpair</code>：全双工的流管道</li>
<li><code>sendmsg</code>和<code>recvmsg</code></li>
<li><code>UNIX</code>域套接字传递描述符字</li>
</ul>
<h2 id="socketpair"><a href="#socketpair" class="headerlink" title="socketpair"></a>socketpair</h2><ul>
<li>功能：创建一个全双工的流管道，只能用于亲缘进程通信。</li>
<li>原型<ul>
<li><code>int socketpair(int domain, int type, int protocol, intsv[2]);</code></li>
</ul>
</li>
<li>参数<ul>
<li><code>domain</code>：协议家族</li>
<li><code>type</code>：套接字类型</li>
<li><code>protocol</code>：协议类型</li>
<li><code>sv</code>：返回套接字对，两个套接字可读可写。</li>
</ul>
</li>
<li>返回值：成功返回<code>0</code>，失败返回<code>-1</code>。</li>
</ul>
<h2 id="sendmsg和recvmsg"><a href="#sendmsg和recvmsg" class="headerlink" title="sendmsg和recvmsg"></a>sendmsg和recvmsg</h2><blockquote>
<p><code>sendmsg</code>：<code>ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags);</code><br><code>recvmsg</code>：<code> ssize_t recvmsg(int sockfd, struct msghdr *msg, int flags);</code></p>
<p>主要为了用<code>UNIX</code>域协议传递套接字，<code>sockfd</code>只能套接字，不能是文件描述符。</p>
<p><code>struct iovec *msg_iov;        /* scatter/gather array */与readv和writev有关，真正所发送的数据。</code></p>
<p><strong>由于存在字节对齐，所以可能会有填充字节。</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct msghdr &#123;</span><br><span class="line">    void         *msg_name;       /* optional address */</span><br><span class="line">    socklen_t     msg_namelen;    /* size of address */</span><br><span class="line">    struct iovec *msg_iov;        /* scatter/gather array */与readv和writev有关，真正所发送的数据。struct iovec</span><br><span class="line">    size_t        msg_iovlen;     /* # elements in msg_iov */发送的iovec()的个数</span><br><span class="line">    void         *msg_control;    /* ancillary data, see below */辅助控制信息，为struct cmsghdr</span><br><span class="line">    size_t        msg_controllen; /* ancillary data buffer len */</span><br><span class="line">    int           msg_flags;      /* flags on received message */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>struct msghdr</code>的成员变量结构体。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// struct iovec *msg_iov;  </span><br><span class="line">struct iovec &#123;                    /* Scatter/gather array items */</span><br><span class="line">    void  *iov_base;              /* Starting address */</span><br><span class="line">    size_t iov_len;               /* Number of bytes to transfer */</span><br><span class="line">&#125;;</span><br><span class="line">//void	*msg_control;</span><br><span class="line">struct cmsghdr &#123;</span><br><span class="line">    size_t cmsg_len;    /* Data byte count, including header (type is socklen_t in POSIX) */</span><br><span class="line">    int    cmsg_level;  /* Originating protocol */</span><br><span class="line">    int    cmsg_type;   /* Protocol-specific type */</span><br><span class="line">    /* followed by </span><br><span class="line">    unsigned char cmsg_data[]; </span><br><span class="line">    */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>readv</code>和<code>writev</code>与<code>struct iovec</code>有关。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssize_t readv(int fd, const struct iovec *iov, int iovcnt);</span><br><span class="line">ssize_t writev(int fd, const struct iovec *iov, int iovcnt);</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>man CMSG_FIRSTHDR</code></p>
<p>参考文档：</p>
<p>​	<a target="_blank" rel="noopener" href="https://blog.csdn.net/sparkliang/article/details/5486069">https://blog.csdn.net/sparkliang/article/details/5486069</a></p>
<p>非亲缘进程之间传递套接字。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line"></span><br><span class="line">struct cmsghdr *CMSG_FIRSTHDR(struct msghdr *msgh);</span><br><span class="line">struct cmsghdr *CMSG_NXTHDR(struct msghdr *msgh, struct cmsghdr *cmsg);</span><br><span class="line">size_t CMSG_ALIGN(size_t length);</span><br><span class="line">size_t CMSG_SPACE(size_t length);</span><br><span class="line">size_t CMSG_LEN(size_t length);</span><br><span class="line">unsigned char *CMSG_DATA(struct cmsghdr *cmsg);</span><br><span class="line"></span><br><span class="line">struct cmsghdr &#123;</span><br><span class="line">    size_t cmsg_len;    /* Data byte count, including header</span><br><span class="line">    (type is socklen_t in POSIX) */</span><br><span class="line">    int    cmsg_level;  /* Originating protocol */</span><br><span class="line">    int    cmsg_type;   /* Protocol-specific type */</span><br><span class="line">    /* followed by</span><br><span class="line">    unsigned char cmsg_data[]; */</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="插播一个vim"><a href="#插播一个vim" class="headerlink" title="插播一个vim"></a>插播一个vim</h2><blockquote>
<p>在<code>vim</code>的插入模式下按<code>insert</code>键，可以进入<code>replace</code>模式</p>
<p>参考文档：<a target="_blank" rel="noopener" href="https://blog.csdn.net/overstack/article/details/9174693">https://blog.csdn.net/overstack/article/details/9174693</a></p>
<p>多行复制：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">例如要将第5到10行黏贴到第15行后面可以这么写：5,10 copy 15 这个方法适合有大量的行数情况。</span><br><span class="line">move：5,10 move 15是移动，类似剪切+复制</span><br><span class="line">delete为删除：5,10 delete删除5到10行</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="sendmsg和recvmsg应用代码"><a href="#sendmsg和recvmsg应用代码" class="headerlink" title="sendmsg和recvmsg应用代码"></a>sendmsg和recvmsg应用代码</h2><blockquote>
<p><code>sendmsg</code>和<code>recvmsg</code>是在父子进程间传递文件描述符的，不能只通过传递文件描述符的数值来传递给别的进程，因为你虽然传递了‘文件描述符’，但是这个只是数值上和文件描述符相等，并不代表真的传递过去了一个文件描述符，<strong>举个简单的例子</strong>：大学都需要考英语四级证书，如果说有人考过了四级，你没有去参加考试，你去把那个人的四级证书复制了一份改成你的名字了，那么不代表你也通过了大学英语四级考试，你只是有一个英语四级证书，而在存储英语四级证书通过人的数据库里面没有你的信息存在。所以你并没有通过四级考试，同理，进程间传递文件描述符，也不能只是简简单单的传递一个<code>fd</code>(这里指那个fd数字)，在你看来<code>fd</code>代表了这个文件，其实不然，在这个<code>fd</code>的背后有着系统对这个<code>fd</code>的一些系列服务的内容，比如你打开了一个文件那么系统就为了维护了这个文件的相关信息，而数字<code>fd</code>系统不过是提供了一个友好的接口来让你方便操作你的那个文件。</p>
<p>且不能通过<code>TCP</code>、<code>UCP</code>传递文件描述符。非亲缘进程的文件描述符的传递只能通过<code>UNIX</code>域协议来传递。</p>
<p>父子进程可以通过<code>socketpair</code>来传递，下面的代码是父子进程通过<code>socketpair</code>来传递文件描述符的。</p>
</blockquote>
<blockquote>
<p><code>send_recv_msg.h</code></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;sys/un.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define ERR_EXIT(x) do&#123;perror(x); exit(EXIT_FAILURE);&#125;while(0)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void send_fd(int sock_fd, int send_fd)</span><br><span class="line">&#123;</span><br><span class="line">	int ret;</span><br><span class="line">	struct msghdr msg;</span><br><span class="line">	struct cmsghdr *p_cmsg;//struct msghdr的第五个成员变量msg_control的辅助控制信息,p_cmsg需要指向一块缓冲区</span><br><span class="line">	struct iovec vec;</span><br><span class="line">	char cmsgbuf[CMSG_SPACE(sizeof(send_fd))];//使用send_fd通过CMSG_SPACE算出来辅助空间的大小，CMEG_SPACE是一个宏.</span><br><span class="line">	int * p_fds;</span><br><span class="line">	char sendchar = 0;</span><br><span class="line"></span><br><span class="line">	msg.msg_control = cmsgbuf;//将msg_control指向cmsgbuf辅助数据</span><br><span class="line">	msg.msg_controllen = sizeof(cmsgbuf);//长度为sizeof(cmsgbuf)</span><br><span class="line"></span><br><span class="line">	p_cmsg = CMSG_FIRSTHDR(&amp;msg);//通过宏CMSG_FIRSTHDR获取msg里面的第一个消息,通过CMSGNXTHDR获取第二个消息，特此说明：是CMSGNXTHDR不是CMSGNEXTHDR这个宏的NEXT没有E。</span><br><span class="line">	p_cmsg-&gt;cmsg_level = SOL_SOCKET;//和下面一句共同表示传递的是文件描述字</span><br><span class="line">	p_cmsg-&gt;cmsg_type = SCM_RIGHTS;</span><br><span class="line">	p_cmsg-&gt;cmsg_len = CMSG_LEN(sizeof(send_fd));//通过宏得到长度</span><br><span class="line">	p_fds = (int *)CMSG_DATA(p_cmsg);//得到数据的首地址</span><br><span class="line">	*p_fds = send_fd;//真正的存放数据的步骤。</span><br><span class="line">	</span><br><span class="line">	//填充struct msghdr结构体变量msg</span><br><span class="line">	msg.msg_name = NULL;</span><br><span class="line">	msg.msg_namelen = 0;</span><br><span class="line">	msg.msg_iov = &amp;vec;</span><br><span class="line">	msg.msg_iovlen = 1;//发送一个字符所以为1</span><br><span class="line">	msg.msg_flags = 0;</span><br><span class="line"></span><br><span class="line">	//填充struct iovec结构体变量vec</span><br><span class="line">	vec.iov_base = &amp;sendchar;//因为只发送一个字符</span><br><span class="line">	vec.iov_len = sizeof(sendchar);//大小为一个字节</span><br><span class="line"></span><br><span class="line">	//数据终于在这里填充完毕了，可以发送数据了</span><br><span class="line">	ret = sendmsg(sock_fd, &amp;msg, 0);</span><br><span class="line">	if(ret != 1)</span><br><span class="line">	&#123;</span><br><span class="line">		ERR_EXIT(&quot;sendmsg&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int  recv_fd(int sock_fd)</span><br><span class="line">&#123;</span><br><span class="line">	int ret;</span><br><span class="line">	struct msghdr msg;</span><br><span class="line">	char recvchar;</span><br><span class="line">	struct iovec vec;</span><br><span class="line">	int recv_fd;</span><br><span class="line">	char cmsgbuf[CMSG_SPACE(sizeof(send_fd))];//使用send_fd通过CMSG_SPACE算出来辅助空间的大小，CMEG_SPACE是一个宏.</span><br><span class="line">	struct cmsghdr *p_cmsg;//struct msghdr的第五个成员变量msg_control的辅助控制信息,p_cmsg需要指向一块缓冲区</span><br><span class="line">	int * p_fds;</span><br><span class="line"></span><br><span class="line">	//填充struct iovec结构体变量vec</span><br><span class="line">	vec.iov_base = &amp;recvchar;//因为只发送一个字符</span><br><span class="line">	vec.iov_len = sizeof(recvchar);//大小为一个字节</span><br><span class="line"></span><br><span class="line">	//填充struct msghdr结构体变量msg</span><br><span class="line">	msg.msg_name = NULL;</span><br><span class="line">	msg.msg_namelen = 0;</span><br><span class="line">	msg.msg_iov = &amp;vec;</span><br><span class="line">	msg.msg_iovlen = 1;//发送一个字符所以为1</span><br><span class="line">	msg.msg_flags = 0;</span><br><span class="line">	msg.msg_control = cmsgbuf;//将msg_control指向cmsgbuf辅助数据</span><br><span class="line">	msg.msg_controllen = sizeof(cmsgbuf);//长度为sizeof(cmsgbuf)</span><br><span class="line">	msg.msg_flags = 0;</span><br><span class="line"></span><br><span class="line">	p_fds = (int *)(CMSG_DATA(CMSG_FIRSTHDR(&amp;msg)));//得到数据的首地址</span><br><span class="line">	*p_fds = -1;//真正的存放数据的步骤。</span><br><span class="line"></span><br><span class="line">	//数据终于在这里填充完毕了，可以接收数据了</span><br><span class="line">	ret = recvmsg(sock_fd, &amp;msg, 0);</span><br><span class="line">	if(ret != 1)</span><br><span class="line">	&#123;</span><br><span class="line">		ERR_EXIT(&quot;recvmsg&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	p_cmsg = CMSG_FIRSTHDR(&amp;msg);</span><br><span class="line">	if(p_cmsg == NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		-ERR_EXIT(&quot;CMSG_FIRSTHDR&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	p_fds = (int *)CMSG_DATA(p_cmsg);</span><br><span class="line">	recv_fd = *p_fds;</span><br><span class="line">	if(recv_fd == -1)</span><br><span class="line">	&#123;</span><br><span class="line">		ERR_EXIT(&quot;CMSG_DATA&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	return recv_fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><blockquote>
<p><code>send_recv_msg.c</code></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;sys/un.h&gt;</span><br><span class="line">#include &quot;sendmsg.h&quot;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define ERR_EXIT(x) do&#123;perror(x); exit(EXIT_FAILURE);&#125;while(0)</span><br><span class="line"></span><br><span class="line">void send_fd(int sock_fd, int send_fd);</span><br><span class="line">int  recv_fd(int sock_fd);</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int sockfds[2];</span><br><span class="line">	if(socketpair(PF_UNIX, SOCK_STREAM, 0, sockfds) &lt; 0)</span><br><span class="line">		ERR_EXIT(&quot;sockfdsetpair&quot;);</span><br><span class="line">	pid_t pid;</span><br><span class="line">	pid = fork();</span><br><span class="line">	if(pid &lt; 0)</span><br><span class="line">	&#123;</span><br><span class="line">		ERR_EXIT(&quot;fork&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	else if(pid == 0)</span><br><span class="line">	&#123;</span><br><span class="line">		//close(sockfds[1]);</span><br><span class="line">		int fd;</span><br><span class="line">		fd = open(&quot;text.txt&quot;, O_RDONLY);</span><br><span class="line">		if(fd == -1)</span><br><span class="line">		&#123;</span><br><span class="line">			ERR_EXIT(&quot;open&quot;);	</span><br><span class="line">		&#125;</span><br><span class="line">		send_fd(sockfds[0], fd);</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		char buf[1024];</span><br><span class="line">		//close(sockfds[0]);</span><br><span class="line">		int fd = recv_fd(sockfds[1]);</span><br><span class="line">		read(fd, buf, sizeof(buf));</span><br><span class="line">		printf(&quot;buf = %s\n&quot;, buf);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/01/19/Socket/day17/" data-id="cm3mpi62e003fl0ya672nh1xt" data-title="17 socketpair、全双工流管道" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/socketpair/" rel="tag">socketpair</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Golang/01Go初识" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/12/14/Golang/01Go%E5%88%9D%E8%AF%86/" class="article-date">
  <time class="dt-published" datetime="2021-12-13T16:00:00.000Z" itemprop="datePublished">2021-12-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Golang%E5%9F%BA%E7%A1%80/">Golang基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/12/14/Golang/01Go%E5%88%9D%E8%AF%86/">01 Golang初识</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="01-Go初识"><a href="#01-Go初识" class="headerlink" title="01 Go初识"></a>01 Go初识</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * 三种不同的打印语句</span><br><span class="line"> * 1. fmt.Println()，可以打印字符串和变量，输出后自动增加一个换行</span><br><span class="line"> * 2. fmt.Printf()，格式化输出</span><br><span class="line"> * 3. fmt.Print()，打印字符串常量</span><br><span class="line"> **/</span><br><span class="line"></span><br><span class="line">func main() &#123; // &#123; 不能单独放一行</span><br><span class="line">	var i int</span><br><span class="line">	for i = 1; i &lt;= 9; i++ &#123;</span><br><span class="line">		for j := 1; j &lt;= i ; j++ &#123;</span><br><span class="line">			// fmt.Print(i, &quot;*&quot;, j, &quot;=&quot;, i*j, &quot;  &quot;)</span><br><span class="line">			fmt.Printf(&quot;%d * %d =%2d &quot;, i, j, i*j)</span><br><span class="line">			// fmt.Println(i, &quot;*&quot;, j, &quot;=&quot;, i*j, &quot;  &quot;) // 最后会换行，无法格式打印9x9乘法表</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/12/14/Golang/01Go%E5%88%9D%E8%AF%86/" data-id="cm3mpi61q0001l0ya5qiqgtcw" data-title="01 Golang初识" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Golang%E5%9F%BA%E7%A1%80/">Golang基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Socket/">Socket</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/LVM%E5%8D%B7/" rel="tag">LVM卷</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/" rel="tag">Linux基础命令</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux%E5%AE%89%E8%A3%85WPS/" rel="tag">Linux安装WPS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux%E6%97%A5%E5%BF%97/" rel="tag">Linux日志</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/" rel="tag">Linux用户管理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/" rel="tag">Linux磁盘管理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux%E8%BF%9B%E7%A8%8B/" rel="tag">Linux进程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/REUSEADDR/" rel="tag">REUSEADDR</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SIGCHLD%E4%BF%A1%E5%8F%B7/" rel="tag">SIGCHLD信号</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SIGPIPPE%E4%BF%A1%E5%8F%B7/" rel="tag">SIGPIPPE信号</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Socket-I-O%E6%A8%A1%E5%9E%8B/" rel="tag">Socket I&#x2F;O模型</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP%E7%9A%8411%E7%A7%8D%E7%8A%B6%E6%80%81/" rel="tag">TCP的11种状态</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98/" rel="tag">TCP粘包问题</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/UDP%E5%9B%9E%E5%B0%84%E5%AE%A2%E6%88%B7%E7%AB%AF/" rel="tag">UDP回射客户端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/UDP%E6%9C%8D%E5%8A%A1%E5%99%A8/" rel="tag">UDP服务器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/UNIX%E5%9F%9F%E5%8D%8F%E8%AE%AE/" rel="tag">UNIX域协议</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/close%E5%87%BD%E6%95%B0-shutdown%E5%87%BD%E6%95%B0/" rel="tag">close函数 - shutdown函数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/epoll%E4%BD%BF%E7%94%A8/" rel="tag">epoll使用</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ftp/" rel="tag">ftp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/select-poll-epoll/" rel="tag">select&amp;poll&amp;epoll</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/select%E5%87%BD%E6%95%B0/" rel="tag">select函数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/select%E6%9C%8D%E5%8A%A1%E5%99%A8/" rel="tag">select服务器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/select%E6%A8%A1%E5%9E%8B/" rel="tag">select模型</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/socket/" rel="tag">socket</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/socketReadline/" rel="tag">socketReadline</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/socketpair/" rel="tag">socketpair</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/socket%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0/" rel="tag">socket相关函数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ssh/" rel="tag">ssh</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vim/" rel="tag">vim</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/yum%E7%AE%A1%E7%90%86/" rel="tag">yum管理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B/" rel="tag">僵尸进程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BB%B6%E6%97%B6%E4%BB%BB%E5%8A%A1/" rel="tag">延时任务</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93/" rel="tag">文件传输</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/" rel="tag">权限控制</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%A1%AC%E7%9B%98%E6%8C%82%E8%BD%BD/" rel="tag">硬盘挂载</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/" rel="tag">网络配置</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85/" rel="tag">虚拟机安装</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/" rel="tag">进程管理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%82%AE%E4%BB%B6%E7%AE%A1%E7%90%86/" rel="tag">邮件管理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%98%B2%E7%81%AB%E5%A2%99/" rel="tag">防火墙</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/LVM%E5%8D%B7/" style="font-size: 10px;">LVM卷</a> <a href="/tags/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/" style="font-size: 10px;">Linux基础命令</a> <a href="/tags/Linux%E5%AE%89%E8%A3%85WPS/" style="font-size: 10px;">Linux安装WPS</a> <a href="/tags/Linux%E6%97%A5%E5%BF%97/" style="font-size: 10px;">Linux日志</a> <a href="/tags/Linux%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/" style="font-size: 10px;">Linux用户管理</a> <a href="/tags/Linux%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/" style="font-size: 10px;">Linux磁盘管理</a> <a href="/tags/Linux%E8%BF%9B%E7%A8%8B/" style="font-size: 10px;">Linux进程</a> <a href="/tags/REUSEADDR/" style="font-size: 10px;">REUSEADDR</a> <a href="/tags/SIGCHLD%E4%BF%A1%E5%8F%B7/" style="font-size: 10px;">SIGCHLD信号</a> <a href="/tags/SIGPIPPE%E4%BF%A1%E5%8F%B7/" style="font-size: 10px;">SIGPIPPE信号</a> <a href="/tags/Socket-I-O%E6%A8%A1%E5%9E%8B/" style="font-size: 10px;">Socket I/O模型</a> <a href="/tags/TCP%E7%9A%8411%E7%A7%8D%E7%8A%B6%E6%80%81/" style="font-size: 10px;">TCP的11种状态</a> <a href="/tags/TCP%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98/" style="font-size: 10px;">TCP粘包问题</a> <a href="/tags/UDP%E5%9B%9E%E5%B0%84%E5%AE%A2%E6%88%B7%E7%AB%AF/" style="font-size: 10px;">UDP回射客户端</a> <a href="/tags/UDP%E6%9C%8D%E5%8A%A1%E5%99%A8/" style="font-size: 10px;">UDP服务器</a> <a href="/tags/UNIX%E5%9F%9F%E5%8D%8F%E8%AE%AE/" style="font-size: 10px;">UNIX域协议</a> <a href="/tags/close%E5%87%BD%E6%95%B0-shutdown%E5%87%BD%E6%95%B0/" style="font-size: 10px;">close函数 - shutdown函数</a> <a href="/tags/epoll%E4%BD%BF%E7%94%A8/" style="font-size: 10px;">epoll使用</a> <a href="/tags/ftp/" style="font-size: 10px;">ftp</a> <a href="/tags/select-poll-epoll/" style="font-size: 10px;">select&poll&epoll</a> <a href="/tags/select%E5%87%BD%E6%95%B0/" style="font-size: 10px;">select函数</a> <a href="/tags/select%E6%9C%8D%E5%8A%A1%E5%99%A8/" style="font-size: 10px;">select服务器</a> <a href="/tags/select%E6%A8%A1%E5%9E%8B/" style="font-size: 10px;">select模型</a> <a href="/tags/socket/" style="font-size: 20px;">socket</a> <a href="/tags/socketReadline/" style="font-size: 10px;">socketReadline</a> <a href="/tags/socketpair/" style="font-size: 10px;">socketpair</a> <a href="/tags/socket%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0/" style="font-size: 10px;">socket相关函数</a> <a href="/tags/ssh/" style="font-size: 10px;">ssh</a> <a href="/tags/vim/" style="font-size: 10px;">vim</a> <a href="/tags/yum%E7%AE%A1%E7%90%86/" style="font-size: 10px;">yum管理</a> <a href="/tags/%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B/" style="font-size: 10px;">僵尸进程</a> <a href="/tags/%E5%BB%B6%E6%97%B6%E4%BB%BB%E5%8A%A1/" style="font-size: 10px;">延时任务</a> <a href="/tags/%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93/" style="font-size: 10px;">文件传输</a> <a href="/tags/%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/" style="font-size: 10px;">权限控制</a> <a href="/tags/%E7%A1%AC%E7%9B%98%E6%8C%82%E8%BD%BD/" style="font-size: 10px;">硬盘挂载</a> <a href="/tags/%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/" style="font-size: 10px;">网络配置</a> <a href="/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85/" style="font-size: 10px;">虚拟机安装</a> <a href="/tags/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/" style="font-size: 10px;">进程管理</a> <a href="/tags/%E9%82%AE%E4%BB%B6%E7%AE%A1%E7%90%86/" style="font-size: 10px;">邮件管理</a> <a href="/tags/%E9%98%B2%E7%81%AB%E5%A2%99/" style="font-size: 10px;">防火墙</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/11/">November 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">January 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">December 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">November 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/11/18/Socket/day15/">(no title)</a>
          </li>
        
          <li>
            <a href="/2024/11/18/Socket/epollsrv/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/01/19/Socket/01%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93/">UDP/TCP文件传输</a>
          </li>
        
          <li>
            <a href="/2022/01/19/Socket/day02/">02 C/S模型、socket相关函数</a>
          </li>
        
          <li>
            <a href="/2022/01/19/Socket/day01/">01 socket 字节序&amp;地址转换函数&amp;套接字类型</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>